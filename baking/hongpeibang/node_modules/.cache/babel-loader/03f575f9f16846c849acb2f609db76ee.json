{"ast":null,"code":"module.exports = function (THREE) {\n  /**\n   * @author felixturner / http://airtight.cc/\n   *\n   * RGB Shift Shader\n   * Shifts red and blue channels from center in opposite directions\n   * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\n   * by Tom Butterworth / http://kriss.cx/tom/\n   *\n   * amount: shift distance (1 is width of input)\n   * angle: shift angle in radians\n   */\n  THREE.DigitalGlitch = {\n    uniforms: {\n      \"tDiffuse\": {\n        type: \"t\",\n        value: null\n      },\n      //diffuse texture\n      \"tDisp\": {\n        type: \"t\",\n        value: null\n      },\n      //displacement texture for digital glitch squares\n      \"byp\": {\n        type: \"i\",\n        value: 0\n      },\n      //apply the glitch ?\n      \"amount\": {\n        type: \"f\",\n        value: 0.08\n      },\n      \"angle\": {\n        type: \"f\",\n        value: 0.02\n      },\n      \"seed\": {\n        type: \"f\",\n        value: 0.02\n      },\n      \"seed_x\": {\n        type: \"f\",\n        value: 0.02\n      },\n      //-1,1\n      \"seed_y\": {\n        type: \"f\",\n        value: 0.02\n      },\n      //-1,1\n      \"distortion_x\": {\n        type: \"f\",\n        value: 0.5\n      },\n      \"distortion_y\": {\n        type: \"f\",\n        value: 0.6\n      },\n      \"col_s\": {\n        type: \"f\",\n        value: 0.05\n      }\n    },\n    vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform int byp;\", //should we apply the glitch ?\n    \"uniform sampler2D tDiffuse;\", \"uniform sampler2D tDisp;\", \"uniform float amount;\", \"uniform float angle;\", \"uniform float seed;\", \"uniform float seed_x;\", \"uniform float seed_y;\", \"uniform float distortion_x;\", \"uniform float distortion_y;\", \"uniform float col_s;\", \"varying vec2 vUv;\", \"float rand(vec2 co){\", \"return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\", \"}\", \"void main() {\", \"if(byp<1) {\", \"vec2 p = vUv;\", \"float xs = floor(gl_FragCoord.x / 0.5);\", \"float ys = floor(gl_FragCoord.y / 0.5);\", //based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\n    \"vec4 normal = texture2D (tDisp, p*seed*seed);\", \"if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {\", \"if(seed_x>0.){\", \"p.y = 1. - (p.y + distortion_y);\", \"}\", \"else {\", \"p.y = distortion_y;\", \"}\", \"}\", \"if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {\", \"if(seed_y>0.){\", \"p.x=distortion_x;\", \"}\", \"else {\", \"p.x = 1. - (p.x + distortion_x);\", \"}\", \"}\", \"p.x+=normal.x*seed_x*(seed/5.);\", \"p.y+=normal.y*seed_y*(seed/5.);\", //base from RGB shift shader\n    \"vec2 offset = amount * vec2( cos(angle), sin(angle));\", \"vec4 cr = texture2D(tDiffuse, p + offset);\", \"vec4 cga = texture2D(tDiffuse, p);\", \"vec4 cb = texture2D(tDiffuse, p - offset);\", \"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\", //add noise\n    \"vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);\", \"gl_FragColor = gl_FragColor+ snow;\", \"}\", \"else {\", \"gl_FragColor=texture2D (tDiffuse, vUv);\", \"}\", \"}\"].join(\"\\n\")\n  };\n};","map":{"version":3,"sources":["E:/baking/hongpeibang/node_modules/three-js/addons/DigitalGlitch.js"],"names":["module","exports","THREE","DigitalGlitch","uniforms","type","value","vertexShader","join","fragmentShader"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiB,UAAUC,KAAV,EAAiB;AACjC;;;;;;;;;;;AAYAA,EAAAA,KAAK,CAACC,aAAN,GAAsB;AAErBC,IAAAA,QAAQ,EAAE;AAET,kBAAa;AAAEC,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAFJ;AAE+B;AACxC,eAAU;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAHD;AAG4B;AACrC,aAAS;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAJA;AAIwB;AACjC,gBAAW;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OALF;AAMT,eAAU;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAND;AAOT,cAAU;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAPD;AAQT,gBAAW;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OARF;AAQ6B;AACtC,gBAAW;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OATF;AAS6B;AACtC,sBAAgB;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAVP;AAWT,sBAAgB;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAXP;AAYT,eAAU;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB;AAZD,KAFW;AAiBrBC,IAAAA,YAAY,EAAE,CAEb,mBAFa,EAGb,eAHa,EAIZ,WAJY,EAKZ,2EALY,EAMb,GANa,EAOZC,IAPY,CAON,IAPM,CAjBO;AA0BrBC,IAAAA,cAAc,EAAE,CACf,kBADe,EACI;AAEnB,iCAHe,EAIf,0BAJe,EAMf,uBANe,EAOf,sBAPe,EAQf,qBARe,EASf,uBATe,EAUf,uBAVe,EAWf,6BAXe,EAYf,6BAZe,EAaf,sBAbe,EAef,mBAfe,EAkBf,sBAlBe,EAmBd,mEAnBc,EAoBf,GApBe,EAsBf,eAtBe,EAuBd,aAvBc,EAwBb,eAxBa,EAyBb,yCAzBa,EA0Bb,yCA1Ba,EA2Bb;AACA,mDA5Ba,EA6Bb,6DA7Ba,EA8BZ,gBA9BY,EA+BX,kCA/BW,EAgCZ,GAhCY,EAiCZ,QAjCY,EAkCX,qBAlCW,EAmCZ,GAnCY,EAoCb,GApCa,EAqCb,6DArCa,EAsCZ,gBAtCY,EAuCX,mBAvCW,EAwCZ,GAxCY,EAyCZ,QAzCY,EA0CX,kCA1CW,EA2CZ,GA3CY,EA4Cb,GA5Ca,EA6Cb,iCA7Ca,EA8Cb,iCA9Ca,EA+Cb;AACA,2DAhDa,EAiDb,4CAjDa,EAkDb,oCAlDa,EAmDb,4CAnDa,EAoDb,gDApDa,EAqDb;AACA,4EAtDa,EAuDb,oCAvDa,EAwDd,GAxDc,EAyDd,QAzDc,EA0Db,yCA1Da,EA2Dd,GA3Dc,EA4Df,GA5De,EA8DdD,IA9Dc,CA8DR,IA9DQ;AA1BK,GAAtB;AA4FA,CAzGD","sourcesContent":["module.exports = function( THREE ){\n\t/**\n\t * @author felixturner / http://airtight.cc/\n\t *\n\t * RGB Shift Shader\n\t * Shifts red and blue channels from center in opposite directions\n\t * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\n\t * by Tom Butterworth / http://kriss.cx/tom/\n\t *\n\t * amount: shift distance (1 is width of input)\n\t * angle: shift angle in radians\n\t */\n\n\tTHREE.DigitalGlitch = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\":\t\t{ type: \"t\", value: null },//diffuse texture\n\t\t\t\"tDisp\":\t\t{ type: \"t\", value: null },//displacement texture for digital glitch squares\n\t\t\t\"byp\":\t\t\t{ type: \"i\", value: 0 },//apply the glitch ?\n\t\t\t\"amount\":\t\t{ type: \"f\", value: 0.08 },\n\t\t\t\"angle\":\t\t{ type: \"f\", value: 0.02 },\n\t\t\t\"seed\":\t\t\t{ type: \"f\", value: 0.02 },\n\t\t\t\"seed_x\":\t\t{ type: \"f\", value: 0.02 },//-1,1\n\t\t\t\"seed_y\":\t\t{ type: \"f\", value: 0.02 },//-1,1\n\t\t\t\"distortion_x\":\t{ type: \"f\", value: 0.5 },\n\t\t\t\"distortion_y\":\t{ type: \"f\", value: 0.6 },\n\t\t\t\"col_s\":\t\t{ type: \"f\", value: 0.05 }\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"void main() {\",\n\t\t\t\t\"vUv = uv;\",\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\"}\"\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\t\t\t\"uniform int byp;\",//should we apply the glitch ?\n\t\t\t\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform sampler2D tDisp;\",\n\t\t\t\n\t\t\t\"uniform float amount;\",\n\t\t\t\"uniform float angle;\",\n\t\t\t\"uniform float seed;\",\n\t\t\t\"uniform float seed_x;\",\n\t\t\t\"uniform float seed_y;\",\n\t\t\t\"uniform float distortion_x;\",\n\t\t\t\"uniform float distortion_y;\",\n\t\t\t\"uniform float col_s;\",\n\t\t\t\t\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\n\t\t\t\n\t\t\t\"float rand(vec2 co){\",\n\t\t\t\t\"return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\",\n\t\t\t\"}\",\n\t\t\t\t\t\n\t\t\t\"void main() {\",\n\t\t\t\t\"if(byp<1) {\",\n\t\t\t\t\t\"vec2 p = vUv;\",\n\t\t\t\t\t\"float xs = floor(gl_FragCoord.x / 0.5);\",\n\t\t\t\t\t\"float ys = floor(gl_FragCoord.y / 0.5);\",\n\t\t\t\t\t//based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\n\t\t\t\t\t\"vec4 normal = texture2D (tDisp, p*seed*seed);\",\n\t\t\t\t\t\"if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {\",\n\t\t\t\t\t\t\"if(seed_x>0.){\",\n\t\t\t\t\t\t\t\"p.y = 1. - (p.y + distortion_y);\",\n\t\t\t\t\t\t\"}\",\n\t\t\t\t\t\t\"else {\",\n\t\t\t\t\t\t\t\"p.y = distortion_y;\",\n\t\t\t\t\t\t\"}\",\n\t\t\t\t\t\"}\",\n\t\t\t\t\t\"if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {\",\n\t\t\t\t\t\t\"if(seed_y>0.){\",\n\t\t\t\t\t\t\t\"p.x=distortion_x;\",\n\t\t\t\t\t\t\"}\",\n\t\t\t\t\t\t\"else {\",\n\t\t\t\t\t\t\t\"p.x = 1. - (p.x + distortion_x);\",\n\t\t\t\t\t\t\"}\",\n\t\t\t\t\t\"}\",\n\t\t\t\t\t\"p.x+=normal.x*seed_x*(seed/5.);\",\n\t\t\t\t\t\"p.y+=normal.y*seed_y*(seed/5.);\",\n\t\t\t\t\t//base from RGB shift shader\n\t\t\t\t\t\"vec2 offset = amount * vec2( cos(angle), sin(angle));\",\n\t\t\t\t\t\"vec4 cr = texture2D(tDiffuse, p + offset);\",\n\t\t\t\t\t\"vec4 cga = texture2D(tDiffuse, p);\",\n\t\t\t\t\t\"vec4 cb = texture2D(tDiffuse, p - offset);\",\n\t\t\t\t\t\"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\",\n\t\t\t\t\t//add noise\n\t\t\t\t\t\"vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);\",\n\t\t\t\t\t\"gl_FragColor = gl_FragColor+ snow;\",\n\t\t\t\t\"}\",\n\t\t\t\t\"else {\",\n\t\t\t\t\t\"gl_FragColor=texture2D (tDiffuse, vUv);\",\n\t\t\t\t\"}\",\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\n}\n"]},"metadata":{},"sourceType":"script"}