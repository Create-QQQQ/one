{"ast":null,"code":"module.exports = function (THREE) {\n  /**\n   * @author miibond\n   * Generate a texture that represents the luminosity of the current scene, adapted over time\n   * to simulate the optic nerve responding to the amount of light it is receiving.\n   * Based on a GDC2007 presentation by Wolfgang Engel titled \"Post-Processing Pipeline\"\n   *\n   * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf\n   */\n  THREE.AdaptiveToneMappingPass = function (adaptive, resolution) {\n    this.resolution = resolution !== undefined ? resolution : 256;\n    this.needsInit = true;\n    this.adaptive = adaptive !== undefined ? !!adaptive : true;\n    this.luminanceRT = null;\n    this.previousLuminanceRT = null;\n    this.currentLuminanceRT = null;\n    if (THREE.CopyShader === undefined) console.error(\"THREE.AdaptiveToneMappingPass relies on THREE.CopyShader\");\n    var copyShader = THREE.CopyShader;\n    this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\n    this.materialCopy = new THREE.ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: THREE.NoBlending,\n      depthTest: false\n    });\n    if (THREE.LuminosityShader === undefined) console.error(\"THREE.AdaptiveToneMappingPass relies on THREE.LuminosityShader\");\n    this.materialLuminance = new THREE.ShaderMaterial({\n      uniforms: THREE.UniformsUtils.clone(THREE.LuminosityShader.uniforms),\n      vertexShader: THREE.LuminosityShader.vertexShader,\n      fragmentShader: THREE.LuminosityShader.fragmentShader,\n      blending: THREE.NoBlending\n    });\n    this.adaptLuminanceShader = {\n      defines: {\n        \"MIP_LEVEL_1X1\": (Math.log(this.resolution) / Math.log(2.0)).toFixed(1)\n      },\n      uniforms: {\n        \"lastLum\": {\n          type: \"t\",\n          value: null\n        },\n        \"currentLum\": {\n          type: \"t\",\n          value: null\n        },\n        \"delta\": {\n          type: 'f',\n          value: 0.016\n        },\n        \"tau\": {\n          type: 'f',\n          value: 1.0\n        }\n      },\n      vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join('\\n'),\n      fragmentShader: [\"varying vec2 vUv;\", \"uniform sampler2D lastLum;\", \"uniform sampler2D currentLum;\", \"uniform float delta;\", \"uniform float tau;\", \"void main() {\", \"vec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );\", \"vec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );\", \"float fLastLum = lastLum.r;\", \"float fCurrentLum = currentLum.r;\", //The adaption seems to work better in extreme lighting differences\n      //if the input luminance is squared.\n      \"fCurrentLum *= fCurrentLum;\", // Adapt the luminance using Pattanaik's technique\n      \"float fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\", // \"fAdaptedLum = sqrt(fAdaptedLum);\",\n      \"gl_FragColor = vec4( vec3( fAdaptedLum ), 1.0 );\", \"}\"].join('\\n')\n    };\n    this.materialAdaptiveLum = new THREE.ShaderMaterial({\n      uniforms: THREE.UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\n      vertexShader: this.adaptLuminanceShader.vertexShader,\n      fragmentShader: this.adaptLuminanceShader.fragmentShader,\n      defines: this.adaptLuminanceShader.defines,\n      blending: THREE.NoBlending\n    });\n    if (THREE.ToneMapShader === undefined) console.error(\"THREE.AdaptiveToneMappingPass relies on THREE.ToneMapShader\");\n    this.materialToneMap = new THREE.ShaderMaterial({\n      uniforms: THREE.UniformsUtils.clone(THREE.ToneMapShader.uniforms),\n      vertexShader: THREE.ToneMapShader.vertexShader,\n      fragmentShader: THREE.ToneMapShader.fragmentShader,\n      blending: THREE.NoBlending\n    });\n    this.enabled = true;\n    this.needsSwap = true;\n    this.clear = false;\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    this.scene = new THREE.Scene();\n    this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n    this.scene.add(this.quad);\n  };\n\n  THREE.AdaptiveToneMappingPass.prototype = {\n    render: function (renderer, writeBuffer, readBuffer, delta, maskActive) {\n      if (this.needsInit) {\n        this.reset(renderer);\n        this.luminanceRT.type = readBuffer.type;\n        this.previousLuminanceRT.type = readBuffer.type;\n        this.currentLuminanceRT.type = readBuffer.type;\n        this.needsInit = false;\n      }\n\n      if (this.adaptive) {\n        //Render the luminance of the current scene into a render target with mipmapping enabled\n        this.quad.material = this.materialLuminance;\n        this.materialLuminance.uniforms.tDiffuse.value = readBuffer;\n        renderer.render(this.scene, this.camera, this.currentLuminanceRT); //Use the new luminance values, the previous luminance and the frame delta to\n        //adapt the luminance over time.\n\n        this.quad.material = this.materialAdaptiveLum;\n        this.materialAdaptiveLum.uniforms.delta.value = delta;\n        this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT;\n        this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT;\n        renderer.render(this.scene, this.camera, this.luminanceRT); //Copy the new adapted luminance value so that it can be used by the next frame.\n\n        this.quad.material = this.materialCopy;\n        this.copyUniforms.tDiffuse.value = this.luminanceRT;\n        renderer.render(this.scene, this.camera, this.previousLuminanceRT);\n      }\n\n      this.quad.material = this.materialToneMap;\n      this.materialToneMap.uniforms.tDiffuse.value = readBuffer;\n      renderer.render(this.scene, this.camera, writeBuffer, this.clear);\n    },\n    reset: function (renderer) {\n      // render targets\n      if (this.luminanceRT) {\n        this.luminanceRT.dispose();\n      }\n\n      if (this.currentLuminanceRT) {\n        this.currentLuminanceRT.dispose();\n      }\n\n      if (this.previousLuminanceRT) {\n        this.previousLuminanceRT.dispose();\n      }\n\n      var pars = {\n        minFilter: THREE.LinearFilter,\n        magFilter: THREE.LinearFilter,\n        format: THREE.RGBFormat\n      };\n      this.luminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, pars);\n      this.luminanceRT.generateMipmaps = false;\n      this.previousLuminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, pars);\n      this.previousLuminanceRT.generateMipmaps = false; //We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader\n\n      pars.minFilter = THREE.LinearMipMapLinearFilter;\n      this.currentLuminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, pars);\n\n      if (this.adaptive) {\n        this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n        this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT;\n      } //Put something in the adaptive luminance texture so that the scene can render initially\n\n\n      this.quad.material = new THREE.MeshBasicMaterial({\n        color: 0x777777\n      });\n      this.materialLuminance.needsUpdate = true;\n      this.materialAdaptiveLum.needsUpdate = true;\n      this.materialToneMap.needsUpdate = true; // renderer.render( this.scene, this.camera, this.luminanceRT );\n      // renderer.render( this.scene, this.camera, this.previousLuminanceRT );\n      // renderer.render( this.scene, this.camera, this.currentLuminanceRT );\n    },\n    setAdaptive: function (adaptive) {\n      if (adaptive) {\n        this.adaptive = true;\n        this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n        this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT;\n      } else {\n        this.adaptive = false;\n        delete this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"];\n        this.materialToneMap.uniforms.luminanceMap.value = undefined;\n      }\n\n      this.materialToneMap.needsUpdate = true;\n    },\n    setAdaptionRate: function (rate) {\n      if (rate) {\n        this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n      }\n    },\n    setMaxLuminance: function (maxLum) {\n      if (maxLum) {\n        this.materialToneMap.uniforms.maxLuminance.value = maxLum;\n      }\n    },\n    setAverageLuminance: function (avgLum) {\n      if (avgLum) {\n        this.materialToneMap.uniforms.averageLuminance.value = avgLum;\n      }\n    },\n    setMiddleGrey: function (middleGrey) {\n      if (middleGrey) {\n        this.materialToneMap.uniforms.middleGrey.value = middleGrey;\n      }\n    },\n    dispose: function () {\n      if (this.luminanceRT) {\n        this.luminanceRT.dispose();\n      }\n\n      if (this.previousLuminanceRT) {\n        this.previousLuminanceRT.dispose();\n      }\n\n      if (this.currentLuminanceRT) {\n        this.currentLuminanceRT.dispose();\n      }\n\n      if (this.materialLuminance) {\n        this.materialLuminance.dispose();\n      }\n\n      if (this.materialAdaptiveLum) {\n        this.materialAdaptiveLum.dispose();\n      }\n\n      if (this.materialCopy) {\n        this.materialCopy.dispose();\n      }\n\n      if (this.materialToneMap) {\n        this.materialToneMap.dispose();\n      }\n    }\n  };\n};","map":{"version":3,"sources":["E:/baking/hongpeibang/node_modules/three-js/addons/AdaptiveToneMappingPass.js"],"names":["module","exports","THREE","AdaptiveToneMappingPass","adaptive","resolution","undefined","needsInit","luminanceRT","previousLuminanceRT","currentLuminanceRT","CopyShader","console","error","copyShader","copyUniforms","UniformsUtils","clone","uniforms","materialCopy","ShaderMaterial","vertexShader","fragmentShader","blending","NoBlending","depthTest","LuminosityShader","materialLuminance","adaptLuminanceShader","defines","Math","log","toFixed","type","value","join","materialAdaptiveLum","ToneMapShader","materialToneMap","enabled","needsSwap","clear","camera","OrthographicCamera","scene","Scene","quad","Mesh","PlaneBufferGeometry","add","prototype","render","renderer","writeBuffer","readBuffer","delta","maskActive","reset","material","tDiffuse","lastLum","currentLum","dispose","pars","minFilter","LinearFilter","magFilter","format","RGBFormat","WebGLRenderTarget","generateMipmaps","LinearMipMapLinearFilter","luminanceMap","MeshBasicMaterial","color","needsUpdate","setAdaptive","setAdaptionRate","rate","tau","abs","setMaxLuminance","maxLum","maxLuminance","setAverageLuminance","avgLum","averageLuminance","setMiddleGrey","middleGrey"],"mappings":"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","sourcesContent":["module.exports = function( THREE ){\n\n\t/**\n\t * @author miibond\n\t * Generate a texture that represents the luminosity of the current scene, adapted over time\n\t * to simulate the optic nerve responding to the amount of light it is receiving.\n\t * Based on a GDC2007 presentation by Wolfgang Engel titled \"Post-Processing Pipeline\"\n\t *\n\t * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf\n\t */\n\n\tTHREE.AdaptiveToneMappingPass = function ( adaptive, resolution ) {\n\n\t\tthis.resolution = ( resolution !== undefined ) ? resolution : 256;\n\t\tthis.needsInit = true;\n\t\tthis.adaptive = adaptive !== undefined ? !! adaptive : true;\n\n\t\tthis.luminanceRT = null;\n\t\tthis.previousLuminanceRT = null;\n\t\tthis.currentLuminanceRT = null;\n\n\t\tif ( THREE.CopyShader === undefined )\n\t\t\tconsole.error( \"THREE.AdaptiveToneMappingPass relies on THREE.CopyShader\" );\n\n\t\tvar copyShader = THREE.CopyShader;\n\n\t\tthis.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );\n\n\t\tthis.materialCopy = new THREE.ShaderMaterial( {\n\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tblending: THREE.NoBlending,\n\t\t\tdepthTest: false\n\n\t\t} );\n\n\t\tif ( THREE.LuminosityShader === undefined )\n\t\t\tconsole.error( \"THREE.AdaptiveToneMappingPass relies on THREE.LuminosityShader\" );\n\n\t\tthis.materialLuminance = new THREE.ShaderMaterial( {\n\n\t\t\tuniforms: THREE.UniformsUtils.clone( THREE.LuminosityShader.uniforms ),\n\t\t\tvertexShader: THREE.LuminosityShader.vertexShader,\n\t\t\tfragmentShader: THREE.LuminosityShader.fragmentShader,\n\t\t\tblending: THREE.NoBlending,\n\t\t} );\n\n\t\tthis.adaptLuminanceShader = {\n\t\t\tdefines: {\n\t\t\t\t\"MIP_LEVEL_1X1\" : ( Math.log( this.resolution ) / Math.log( 2.0 ) ).toFixed( 1 ),\n\t\t\t},\n\t\t\tuniforms: {\n\t\t\t\t\"lastLum\": { type: \"t\", value: null },\n\t\t\t\t\"currentLum\": { type: \"t\", value: null },\n\t\t\t\t\"delta\": { type: 'f', value: 0.016 },\n\t\t\t\t\"tau\": { type: 'f', value: 1.0 }\n\t\t\t},\n\t\t\tvertexShader: [\n\t\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\"vUv = uv;\",\n\t\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\t\"}\"\n\t\t\t].join( '\\n' ),\n\t\t\tfragmentShader: [\n\t\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\t\"uniform sampler2D lastLum;\",\n\t\t\t\t\"uniform sampler2D currentLum;\",\n\t\t\t\t\"uniform float delta;\",\n\t\t\t\t\"uniform float tau;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\"vec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );\",\n\t\t\t\t\t\"vec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );\",\n\n\t\t\t\t\t\"float fLastLum = lastLum.r;\",\n\t\t\t\t\t\"float fCurrentLum = currentLum.r;\",\n\n\t\t\t\t\t//The adaption seems to work better in extreme lighting differences\n\t\t\t\t\t//if the input luminance is squared.\n\t\t\t\t\t\"fCurrentLum *= fCurrentLum;\",\n\n\t\t\t\t\t// Adapt the luminance using Pattanaik's technique\n\t\t\t\t\t\"float fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\",\n\t\t\t\t\t// \"fAdaptedLum = sqrt(fAdaptedLum);\",\n\t\t\t\t\t\"gl_FragColor = vec4( vec3( fAdaptedLum ), 1.0 );\",\n\t\t\t\t\"}\",\n\t\t\t].join( '\\n' )\n\t\t};\n\n\t\tthis.materialAdaptiveLum = new THREE.ShaderMaterial( {\n\n\t\t\tuniforms: THREE.UniformsUtils.clone( this.adaptLuminanceShader.uniforms ),\n\t\t\tvertexShader: this.adaptLuminanceShader.vertexShader,\n\t\t\tfragmentShader: this.adaptLuminanceShader.fragmentShader,\n\t\t\tdefines: this.adaptLuminanceShader.defines,\n\t\t\tblending: THREE.NoBlending\n\t\t} );\n\n\t\tif ( THREE.ToneMapShader === undefined )\n\t\t\tconsole.error( \"THREE.AdaptiveToneMappingPass relies on THREE.ToneMapShader\" );\n\n\t\tthis.materialToneMap = new THREE.ShaderMaterial( {\n\n\t\t\tuniforms: THREE.UniformsUtils.clone( THREE.ToneMapShader.uniforms ),\n\t\t\tvertexShader: THREE.ToneMapShader.vertexShader,\n\t\t\tfragmentShader: THREE.ToneMapShader.fragmentShader,\n\t\t\tblending: THREE.NoBlending\n\t\t} );\n\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = true;\n\t\tthis.clear = false;\n\n\t\tthis.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\t\tthis.scene  = new THREE.Scene();\n\n\t\tthis.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );\n\t\tthis.scene.add( this.quad );\n\n\t};\n\n\tTHREE.AdaptiveToneMappingPass.prototype = {\n\n\t\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\n\n\t\t\tif ( this.needsInit ) {\n\n\t\t\t\tthis.reset( renderer );\n\t\t\t\tthis.luminanceRT.type = readBuffer.type;\n\t\t\t\tthis.previousLuminanceRT.type = readBuffer.type;\n\t\t\t\tthis.currentLuminanceRT.type = readBuffer.type;\n\t\t\t\tthis.needsInit = false;\n\n\t\t\t}\n\n\t\t\tif ( this.adaptive ) {\n\n\t\t\t\t//Render the luminance of the current scene into a render target with mipmapping enabled\n\t\t\t\tthis.quad.material = this.materialLuminance;\n\t\t\t\tthis.materialLuminance.uniforms.tDiffuse.value = readBuffer;\n\t\t\t\trenderer.render( this.scene, this.camera, this.currentLuminanceRT );\n\n\t\t\t\t//Use the new luminance values, the previous luminance and the frame delta to\n\t\t\t\t//adapt the luminance over time.\n\t\t\t\tthis.quad.material = this.materialAdaptiveLum;\n\t\t\t\tthis.materialAdaptiveLum.uniforms.delta.value = delta;\n\t\t\t\tthis.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT;\n\t\t\t\tthis.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT;\n\t\t\t\trenderer.render( this.scene, this.camera, this.luminanceRT );\n\n\t\t\t\t//Copy the new adapted luminance value so that it can be used by the next frame.\n\t\t\t\tthis.quad.material = this.materialCopy;\n\t\t\t\tthis.copyUniforms.tDiffuse.value = this.luminanceRT;\n\t\t\t\trenderer.render( this.scene, this.camera, this.previousLuminanceRT );\n\n\t\t\t}\n\n\t\t\tthis.quad.material = this.materialToneMap;\n\t\t\tthis.materialToneMap.uniforms.tDiffuse.value = readBuffer;\n\t\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\n\n\t\t},\n\n\t\treset: function( renderer ) {\n\n\t\t\t// render targets\n\t\t\tif ( this.luminanceRT ) {\n\n\t\t\t\tthis.luminanceRT.dispose();\n\n\t\t\t}\n\t\t\tif ( this.currentLuminanceRT ) {\n\n\t\t\t\tthis.currentLuminanceRT.dispose();\n\n\t\t\t}\n\t\t\tif ( this.previousLuminanceRT ) {\n\n\t\t\t\tthis.previousLuminanceRT.dispose();\n\n\t\t\t}\n\t\t\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };\n\n\t\t\tthis.luminanceRT = new THREE.WebGLRenderTarget( this.resolution, this.resolution, pars );\n\t\t\tthis.luminanceRT.generateMipmaps = false;\n\t\t\tthis.previousLuminanceRT = new THREE.WebGLRenderTarget( this.resolution, this.resolution, pars );\n\t\t\tthis.previousLuminanceRT.generateMipmaps = false;\n\n\t\t\t//We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader\n\t\t\tpars.minFilter = THREE.LinearMipMapLinearFilter;\n\t\t\tthis.currentLuminanceRT = new THREE.WebGLRenderTarget( this.resolution, this.resolution, pars );\n\n\t\t\tif ( this.adaptive ) {\n\n\t\t\t\tthis.materialToneMap.defines[ \"ADAPTED_LUMINANCE\" ] = \"\";\n\t\t\t\tthis.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT;\n\n\t\t\t}\n\t\t\t//Put something in the adaptive luminance texture so that the scene can render initially\n\t\t\tthis.quad.material = new THREE.MeshBasicMaterial( { color: 0x777777 } );\n\t\t\tthis.materialLuminance.needsUpdate = true;\n\t\t\tthis.materialAdaptiveLum.needsUpdate = true;\n\t\t\tthis.materialToneMap.needsUpdate = true;\n\t\t\t// renderer.render( this.scene, this.camera, this.luminanceRT );\n\t\t\t// renderer.render( this.scene, this.camera, this.previousLuminanceRT );\n\t\t\t// renderer.render( this.scene, this.camera, this.currentLuminanceRT );\n\n\t\t},\n\n\t\tsetAdaptive: function( adaptive ) {\n\n\t\t\tif ( adaptive ) {\n\n\t\t\t\tthis.adaptive = true;\n\t\t\t\tthis.materialToneMap.defines[ \"ADAPTED_LUMINANCE\" ] = \"\";\n\t\t\t\tthis.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT;\n\n\t\t\t} else {\n\n\t\t\t\tthis.adaptive = false;\n\t\t\t\tdelete this.materialToneMap.defines[ \"ADAPTED_LUMINANCE\" ];\n\t\t\t\tthis.materialToneMap.uniforms.luminanceMap.value = undefined;\n\n\t\t\t}\n\t\t\tthis.materialToneMap.needsUpdate = true;\n\n\t\t},\n\n\t\tsetAdaptionRate: function( rate ) {\n\n\t\t\tif ( rate ) {\n\n\t\t\t\tthis.materialAdaptiveLum.uniforms.tau.value = Math.abs( rate );\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetMaxLuminance: function( maxLum ) {\n\n\t\t\tif ( maxLum ) {\n\n\t\t\t\tthis.materialToneMap.uniforms.maxLuminance.value = maxLum;\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetAverageLuminance: function( avgLum ) {\n\n\t\t\tif ( avgLum ) {\n\n\t\t\t\tthis.materialToneMap.uniforms.averageLuminance.value = avgLum;\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetMiddleGrey: function( middleGrey ) {\n\n\t\t\tif ( middleGrey ) {\n\n\t\t\t\tthis.materialToneMap.uniforms.middleGrey.value = middleGrey;\n\n\t\t\t}\n\n\t\t},\n\n\t\tdispose: function() {\n\n\t\t\tif ( this.luminanceRT ) {\n\n\t\t\t\tthis.luminanceRT.dispose();\n\n\t\t\t}\n\t\t\tif ( this.previousLuminanceRT ) {\n\n\t\t\t\tthis.previousLuminanceRT.dispose();\n\n\t\t\t}\n\t\t\tif ( this.currentLuminanceRT ) {\n\n\t\t\t\tthis.currentLuminanceRT.dispose();\n\n\t\t\t}\n\t\t\tif ( this.materialLuminance ) {\n\n\t\t\t\tthis.materialLuminance.dispose();\n\n\t\t\t}\n\t\t\tif ( this.materialAdaptiveLum ) {\n\n\t\t\t\tthis.materialAdaptiveLum.dispose();\n\n\t\t\t}\n\t\t\tif ( this.materialCopy ) {\n\n\t\t\t\tthis.materialCopy.dispose();\n\n\t\t\t}\n\t\t\tif ( this.materialToneMap ) {\n\n\t\t\t\tthis.materialToneMap.dispose();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n}\n"]},"metadata":{},"sourceType":"script"}