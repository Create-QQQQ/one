{"ast":null,"code":"module.exports = function (THREE) {\n  // Author: Aleksandr Albert\n  // Website: www.routter.co.tt\n  // Description: A deep water ocean shader set\n  // based on an implementation of a Tessendorf Waves\n  // originally presented by David Li ( www.david.li/waves )\n  // The general method is to apply shaders to simulation Framebuffers\n  // and then sample these framebuffers when rendering the ocean mesh\n  // The set uses 7 shaders:\n  // -- Simulation shaders\n  // [1] ocean_sim_vertex         -> Vertex shader used to set up a 2x2 simulation plane centered at (0,0)\n  // [2] ocean_subtransform       -> Fragment shader used to subtransform the mesh (generates the displacement map)\n  // [3] ocean_initial_spectrum   -> Fragment shader used to set intitial wave frequency at a texel coordinate\n  // [4] ocean_phase              -> Fragment shader used to set wave phase at a texel coordinate\n  // [5] ocean_spectrum           -> Fragment shader used to set current wave frequency at a texel coordinate\n  // [6] ocean_normal             -> Fragment shader used to set face normals at a texel coordinate\n  // -- Rendering Shader\n  // [7] ocean_main               -> Vertex and Fragment shader used to create the final render\n  THREE.ShaderLib['ocean_sim_vertex'] = {\n    varying: {\n      \"vUV\": {\n        type: \"v2\"\n      }\n    },\n    vertexShader: ['varying vec2 vUV;', 'void main (void) {', 'vUV = position.xy * 0.5 + 0.5;', 'gl_Position = vec4(position, 1.0 );', '}'].join('\\n')\n  };\n  THREE.ShaderLib['ocean_subtransform'] = {\n    uniforms: {\n      \"u_input\": {\n        type: \"t\",\n        value: null\n      },\n      \"u_transformSize\": {\n        type: \"f\",\n        value: 512.0\n      },\n      \"u_subtransformSize\": {\n        type: \"f\",\n        value: 250.0\n      }\n    },\n    varying: {\n      \"vUV\": {\n        type: \"v2\"\n      }\n    },\n    fragmentShader: [//GPU FFT using a Stockham formulation\n    'precision highp float;', 'const float PI = 3.14159265359;', 'uniform sampler2D u_input;', 'uniform float u_transformSize;', 'uniform float u_subtransformSize;', 'varying vec2 vUV;', 'vec2 multiplyComplex (vec2 a, vec2 b) {', 'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);', '}', 'void main (void) {', '#ifdef HORIZONTAL', 'float index = vUV.x * u_transformSize - 0.5;', '#else', 'float index = vUV.y * u_transformSize - 0.5;', '#endif', 'float evenIndex = floor(index / u_subtransformSize) * (u_subtransformSize * 0.5) + mod(index, u_subtransformSize * 0.5);', //transform two complex sequences simultaneously\n    '#ifdef HORIZONTAL', 'vec4 even = texture2D(u_input, vec2(evenIndex + 0.5, gl_FragCoord.y) / u_transformSize).rgba;', 'vec4 odd = texture2D(u_input, vec2(evenIndex + u_transformSize * 0.5 + 0.5, gl_FragCoord.y) / u_transformSize).rgba;', '#else', 'vec4 even = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + 0.5) / u_transformSize).rgba;', 'vec4 odd = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + u_transformSize * 0.5 + 0.5) / u_transformSize).rgba;', '#endif', 'float twiddleArgument = -2.0 * PI * (index / u_subtransformSize);', 'vec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));', 'vec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);', 'vec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);', 'gl_FragColor = vec4(outputA, outputB);', '}'].join('\\n')\n  };\n  THREE.ShaderLib['ocean_initial_spectrum'] = {\n    uniforms: {\n      \"u_wind\": {\n        type: \"v2\",\n        value: new THREE.Vector2(10.0, 10.0)\n      },\n      \"u_resolution\": {\n        type: \"f\",\n        value: 512.0\n      },\n      \"u_size\": {\n        type: \"f\",\n        value: 250.0\n      }\n    },\n    fragmentShader: ['precision highp float;', 'const float PI = 3.14159265359;', 'const float G = 9.81;', 'const float KM = 370.0;', 'const float CM = 0.23;', 'uniform vec2 u_wind;', 'uniform float u_resolution;', 'uniform float u_size;', 'float square (float x) {', 'return x * x;', '}', 'float omega (float k) {', 'return sqrt(G * k * (1.0 + square(k / KM)));', '}', 'float tanh (float x) {', 'return (1.0 - exp(-2.0 * x)) / (1.0 + exp(-2.0 * x));', '}', 'void main (void) {', 'vec2 coordinates = gl_FragCoord.xy - 0.5;', 'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;', 'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;', 'vec2 K = (2.0 * PI * vec2(n, m)) / u_size;', 'float k = length(K);', 'float l_wind = length(u_wind);', 'float Omega = 0.84;', 'float kp = G * square(Omega / l_wind);', 'float c = omega(k) / k;', 'float cp = omega(kp) / kp;', 'float Lpm = exp(-1.25 * square(kp / k));', 'float gamma = 1.7;', 'float sigma = 0.08 * (1.0 + 4.0 * pow(Omega, -3.0));', 'float Gamma = exp(-square(sqrt(k / kp) - 1.0) / 2.0 * square(sigma));', 'float Jp = pow(gamma, Gamma);', 'float Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0));', 'float alphap = 0.006 * sqrt(Omega);', 'float Bl = 0.5 * alphap * cp / c * Fp;', 'float z0 = 0.000037 * square(l_wind) / G * pow(l_wind / cp, 0.9);', 'float uStar = 0.41 * l_wind / log(10.0 / z0);', 'float alpham = 0.01 * ((uStar < CM) ? (1.0 + log(uStar / CM)) : (1.0 + 3.0 * log(uStar / CM)));', 'float Fm = exp(-0.25 * square(k / KM - 1.0));', 'float Bh = 0.5 * alpham * CM / c * Fm * Lpm;', 'float a0 = log(2.0) / 4.0;', 'float am = 0.13 * uStar / CM;', 'float Delta = tanh(a0 + 4.0 * pow(c / cp, 2.5) + am * pow(CM / c, 2.5));', 'float cosPhi = dot(normalize(u_wind), normalize(K));', 'float S = (1.0 / (2.0 * PI)) * pow(k, -4.0) * (Bl + Bh) * (1.0 + Delta * (2.0 * cosPhi * cosPhi - 1.0));', 'float dk = 2.0 * PI / u_size;', 'float h = sqrt(S / 2.0) * dk;', 'if (K.x == 0.0 && K.y == 0.0) {', 'h = 0.0;', //no DC term\n    '}', 'gl_FragColor = vec4(h, 0.0, 0.0, 0.0);', '}'].join('\\n')\n  };\n  THREE.ShaderLib['ocean_phase'] = {\n    uniforms: {\n      \"u_phases\": {\n        type: \"t\",\n        value: null\n      },\n      \"u_deltaTime\": {\n        type: \"f\",\n        value: null\n      },\n      \"u_resolution\": {\n        type: \"f\",\n        value: null\n      },\n      \"u_size\": {\n        type: \"f\",\n        value: null\n      }\n    },\n    varying: {\n      \"vUV\": {\n        type: \"v2\"\n      }\n    },\n    fragmentShader: ['precision highp float;', 'const float PI = 3.14159265359;', 'const float G = 9.81;', 'const float KM = 370.0;', 'varying vec2 vUV;', 'uniform sampler2D u_phases;', 'uniform float u_deltaTime;', 'uniform float u_resolution;', 'uniform float u_size;', 'float omega (float k) {', 'return sqrt(G * k * (1.0 + k * k / KM * KM));', '}', 'void main (void) {', 'float deltaTime = 1.0 / 60.0;', 'vec2 coordinates = gl_FragCoord.xy - 0.5;', 'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;', 'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;', 'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;', 'float phase = texture2D(u_phases, vUV).r;', 'float deltaPhase = omega(length(waveVector)) * u_deltaTime;', 'phase = mod(phase + deltaPhase, 2.0 * PI);', 'gl_FragColor = vec4(phase, 0.0, 0.0, 0.0);', '}'].join('\\n')\n  };\n  THREE.ShaderLib['ocean_spectrum'] = {\n    uniforms: {\n      \"u_size\": {\n        type: \"f\",\n        value: null\n      },\n      \"u_resolution\": {\n        type: \"f\",\n        value: null\n      },\n      \"u_choppiness\": {\n        type: \"f\",\n        value: null\n      },\n      \"u_phases\": {\n        type: \"t\",\n        value: null\n      },\n      \"u_initialSpectrum\": {\n        type: \"t\",\n        value: null\n      }\n    },\n    varying: {\n      \"vUV\": {\n        type: \"v2\"\n      }\n    },\n    fragmentShader: ['precision highp float;', 'const float PI = 3.14159265359;', 'const float G = 9.81;', 'const float KM = 370.0;', 'varying vec2 vUV;', 'uniform float u_size;', 'uniform float u_resolution;', 'uniform float u_choppiness;', 'uniform sampler2D u_phases;', 'uniform sampler2D u_initialSpectrum;', 'vec2 multiplyComplex (vec2 a, vec2 b) {', 'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);', '}', 'vec2 multiplyByI (vec2 z) {', 'return vec2(-z[1], z[0]);', '}', 'float omega (float k) {', 'return sqrt(G * k * (1.0 + k * k / KM * KM));', '}', 'void main (void) {', 'vec2 coordinates = gl_FragCoord.xy - 0.5;', 'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;', 'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;', 'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;', 'float phase = texture2D(u_phases, vUV).r;', 'vec2 phaseVector = vec2(cos(phase), sin(phase));', 'vec2 h0 = texture2D(u_initialSpectrum, vUV).rg;', 'vec2 h0Star = texture2D(u_initialSpectrum, vec2(1.0 - vUV + 1.0 / u_resolution)).rg;', 'h0Star.y *= -1.0;', 'vec2 h = multiplyComplex(h0, phaseVector) + multiplyComplex(h0Star, vec2(phaseVector.x, -phaseVector.y));', 'vec2 hX = -multiplyByI(h * (waveVector.x / length(waveVector))) * u_choppiness;', 'vec2 hZ = -multiplyByI(h * (waveVector.y / length(waveVector))) * u_choppiness;', //no DC term\n    'if (waveVector.x == 0.0 && waveVector.y == 0.0) {', 'h = vec2(0.0);', 'hX = vec2(0.0);', 'hZ = vec2(0.0);', '}', 'gl_FragColor = vec4(hX + multiplyByI(h), hZ);', '}'].join('\\n')\n  };\n  THREE.ShaderLib['ocean_normals'] = {\n    uniforms: {\n      \"u_displacementMap\": {\n        type: \"t\",\n        value: null\n      },\n      \"u_resolution\": {\n        type: \"f\",\n        value: null\n      },\n      \"u_size\": {\n        type: \"f\",\n        value: null\n      }\n    },\n    varying: {\n      \"vUV\": {\n        type: \"v2\"\n      }\n    },\n    fragmentShader: ['precision highp float;', 'varying vec2 vUV;', 'uniform sampler2D u_displacementMap;', 'uniform float u_resolution;', 'uniform float u_size;', 'void main (void) {', 'float texel = 1.0 / u_resolution;', 'float texelSize = u_size / u_resolution;', 'vec3 center = texture2D(u_displacementMap, vUV).rgb;', 'vec3 right = vec3(texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(texel, 0.0)).rgb - center;', 'vec3 left = vec3(-texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(-texel, 0.0)).rgb - center;', 'vec3 top = vec3(0.0, 0.0, -texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, -texel)).rgb - center;', 'vec3 bottom = vec3(0.0, 0.0, texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, texel)).rgb - center;', 'vec3 topRight = cross(right, top);', 'vec3 topLeft = cross(top, left);', 'vec3 bottomLeft = cross(left, bottom);', 'vec3 bottomRight = cross(bottom, right);', 'gl_FragColor = vec4(normalize(topRight + topLeft + bottomLeft + bottomRight), 1.0);', '}'].join('\\n')\n  };\n  THREE.ShaderLib['ocean_main'] = {\n    uniforms: {\n      \"u_displacementMap\": {\n        type: \"t\",\n        value: null\n      },\n      \"u_normalMap\": {\n        type: \"t\",\n        value: null\n      },\n      \"u_geometrySize\": {\n        type: \"f\",\n        value: null\n      },\n      \"u_size\": {\n        type: \"f\",\n        value: null\n      },\n      \"u_projectionMatrix\": {\n        type: \"m4\",\n        value: null\n      },\n      \"u_viewMatrix\": {\n        type: \"m4\",\n        value: null\n      },\n      \"u_cameraPosition\": {\n        type: \"v3\",\n        value: null\n      },\n      \"u_skyColor\": {\n        type: \"v3\",\n        value: null\n      },\n      \"u_oceanColor\": {\n        type: \"v3\",\n        value: null\n      },\n      \"u_sunDirection\": {\n        type: \"v3\",\n        value: null\n      },\n      \"u_exposure\": {\n        type: \"f\",\n        value: null\n      }\n    },\n    varying: {\n      \"vPos\": {\n        type: \"v3\"\n      },\n      \"vUV\": {\n        type: \"v2\"\n      }\n    },\n    vertexShader: ['precision highp float;', 'varying vec3 vPos;', 'varying vec2 vUV;', 'uniform mat4 u_projectionMatrix;', 'uniform mat4 u_viewMatrix;', 'uniform float u_size;', 'uniform float u_geometrySize;', 'uniform sampler2D u_displacementMap;', 'void main (void) {', 'vec3 newPos = position + texture2D(u_displacementMap, uv).rgb * (u_geometrySize / u_size);', 'vPos = newPos;', 'vUV = uv;', 'gl_Position = u_projectionMatrix * u_viewMatrix * vec4(newPos, 1.0);', '}'].join('\\n'),\n    fragmentShader: ['precision highp float;', 'varying vec3 vPos;', 'varying vec2 vUV;', 'uniform sampler2D u_displacementMap;', 'uniform sampler2D u_normalMap;', 'uniform vec3 u_cameraPosition;', 'uniform vec3 u_oceanColor;', 'uniform vec3 u_skyColor;', 'uniform vec3 u_sunDirection;', 'uniform float u_exposure;', 'vec3 hdr (vec3 color, float exposure) {', 'return 1.0 - exp(-color * exposure);', '}', 'void main (void) {', 'vec3 normal = texture2D(u_normalMap, vUV).rgb;', 'vec3 view = normalize(u_cameraPosition - vPos);', 'float fresnel = 0.02 + 0.98 * pow(1.0 - dot(normal, view), 5.0);', 'vec3 sky = fresnel * u_skyColor;', 'float diffuse = clamp(dot(normal, normalize(u_sunDirection)), 0.0, 1.0);', 'vec3 water = (1.0 - fresnel) * u_oceanColor * u_skyColor * diffuse;', 'vec3 color = sky + water;', 'gl_FragColor = vec4(hdr(color, u_exposure), 1.0);', '}'].join('\\n')\n  };\n};","map":{"version":3,"sources":["E:/baking/hongpeibang/node_modules/three-js/addons/OceanShaders.js"],"names":["module","exports","THREE","ShaderLib","varying","type","vertexShader","join","uniforms","value","fragmentShader","Vector2"],"mappings":"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","sourcesContent":["module.exports = function( THREE ){\n\t// Author: Aleksandr Albert\n\t// Website: www.routter.co.tt\n\n\t// Description: A deep water ocean shader set\n\t// based on an implementation of a Tessendorf Waves\n\t// originally presented by David Li ( www.david.li/waves )\n\n\t// The general method is to apply shaders to simulation Framebuffers\n\t// and then sample these framebuffers when rendering the ocean mesh\n\n\t// The set uses 7 shaders:\n\n\t// -- Simulation shaders\n\t// [1] ocean_sim_vertex         -> Vertex shader used to set up a 2x2 simulation plane centered at (0,0)\n\t// [2] ocean_subtransform       -> Fragment shader used to subtransform the mesh (generates the displacement map)\n\t// [3] ocean_initial_spectrum   -> Fragment shader used to set intitial wave frequency at a texel coordinate\n\t// [4] ocean_phase              -> Fragment shader used to set wave phase at a texel coordinate\n\t// [5] ocean_spectrum           -> Fragment shader used to set current wave frequency at a texel coordinate\n\t// [6] ocean_normal             -> Fragment shader used to set face normals at a texel coordinate\n\n\t// -- Rendering Shader\n\t// [7] ocean_main               -> Vertex and Fragment shader used to create the final render\n\n\n\tTHREE.ShaderLib[ 'ocean_sim_vertex' ] = {\n\t\tvarying: {\n\t\t\t\"vUV\": { type: \"v2\" }\n\t\t},\n\t\tvertexShader: [\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'void main (void) {',\n\t\t\t\t'vUV = position.xy * 0.5 + 0.5;',\n\t\t\t\t'gl_Position = vec4(position, 1.0 );',\n\t\t\t'}'\n\t\t].join( '\\n' )\n\t};\n\tTHREE.ShaderLib[ 'ocean_subtransform' ] = {\n\t\tuniforms: {\n\t\t\t\"u_input\": { type: \"t\", value: null },\n\t\t\t\"u_transformSize\": { type: \"f\", value: 512.0 },\n\t\t\t\"u_subtransformSize\": { type: \"f\", value: 250.0 }\n\t\t},\n\t\tvarying: {\n\t\t\t\"vUV\": { type: \"v2\" }\n\t\t},\n\t\tfragmentShader: [\n\t\t\t//GPU FFT using a Stockham formulation\n\t\t\t'precision highp float;',\n\n\t\t\t'const float PI = 3.14159265359;',\n\n\t\t\t'uniform sampler2D u_input;',\n\t\t\t'uniform float u_transformSize;',\n\t\t\t'uniform float u_subtransformSize;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'vec2 multiplyComplex (vec2 a, vec2 b) {',\n\t\t\t\t'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);',\n\t\t\t'}',\n\n\t\t\t'void main (void) {',\n\t\t\t\t'#ifdef HORIZONTAL',\n\t\t\t\t'float index = vUV.x * u_transformSize - 0.5;',\n\t\t\t\t'#else',\n\t\t\t\t'float index = vUV.y * u_transformSize - 0.5;',\n\t\t\t\t'#endif',\n\n\t\t\t\t'float evenIndex = floor(index / u_subtransformSize) * (u_subtransformSize * 0.5) + mod(index, u_subtransformSize * 0.5);',\n\n\t\t\t\t//transform two complex sequences simultaneously\n\t\t\t\t'#ifdef HORIZONTAL',\n\t\t\t\t'vec4 even = texture2D(u_input, vec2(evenIndex + 0.5, gl_FragCoord.y) / u_transformSize).rgba;',\n\t\t\t\t'vec4 odd = texture2D(u_input, vec2(evenIndex + u_transformSize * 0.5 + 0.5, gl_FragCoord.y) / u_transformSize).rgba;',\n\t\t\t\t'#else',\n\t\t\t\t'vec4 even = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + 0.5) / u_transformSize).rgba;',\n\t\t\t\t'vec4 odd = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + u_transformSize * 0.5 + 0.5) / u_transformSize).rgba;',\n\t\t\t\t'#endif',\n\n\t\t\t\t'float twiddleArgument = -2.0 * PI * (index / u_subtransformSize);',\n\t\t\t\t'vec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));',\n\n\t\t\t\t'vec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);',\n\t\t\t\t'vec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);',\n\n\t\t\t\t'gl_FragColor = vec4(outputA, outputB);',\n\t\t\t'}'\n\t\t].join( '\\n' )\n\t};\n\tTHREE.ShaderLib[ 'ocean_initial_spectrum' ] = {\n\t\tuniforms: {\n\t\t\t\"u_wind\": { type: \"v2\", value: new THREE.Vector2( 10.0, 10.0 ) },\n\t\t\t\"u_resolution\": { type: \"f\", value: 512.0 },\n\t\t\t\"u_size\": { type: \"f\", value: 250.0 },\n\t\t},\n\t\tfragmentShader: [\n\t\t\t'precision highp float;',\n\n\t\t\t'const float PI = 3.14159265359;',\n\t\t\t'const float G = 9.81;',\n\t\t\t'const float KM = 370.0;',\n\t\t\t'const float CM = 0.23;',\n\n\t\t\t'uniform vec2 u_wind;',\n\t\t\t'uniform float u_resolution;',\n\t\t\t'uniform float u_size;',\n\n\t\t\t'float square (float x) {',\n\t\t\t\t'return x * x;',\n\t\t\t'}',\n\n\t\t\t'float omega (float k) {',\n\t\t\t\t'return sqrt(G * k * (1.0 + square(k / KM)));',\n\t\t\t'}',\n\n\t\t\t'float tanh (float x) {',\n\t\t\t\t'return (1.0 - exp(-2.0 * x)) / (1.0 + exp(-2.0 * x));',\n\t\t\t'}',\n\n\t\t\t'void main (void) {',\n\t\t\t\t'vec2 coordinates = gl_FragCoord.xy - 0.5;',\n\n\t\t\t\t'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;',\n\t\t\t\t'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;',\n\n\t\t\t\t'vec2 K = (2.0 * PI * vec2(n, m)) / u_size;',\n\t\t\t\t'float k = length(K);',\n\n\t\t\t\t'float l_wind = length(u_wind);',\n\n\t\t\t\t'float Omega = 0.84;',\n\t\t\t\t'float kp = G * square(Omega / l_wind);',\n\n\t\t\t\t'float c = omega(k) / k;',\n\t\t\t\t'float cp = omega(kp) / kp;',\n\n\t\t\t\t'float Lpm = exp(-1.25 * square(kp / k));',\n\t\t\t\t'float gamma = 1.7;',\n\t\t\t\t'float sigma = 0.08 * (1.0 + 4.0 * pow(Omega, -3.0));',\n\t\t\t\t'float Gamma = exp(-square(sqrt(k / kp) - 1.0) / 2.0 * square(sigma));',\n\t\t\t\t'float Jp = pow(gamma, Gamma);',\n\t\t\t\t'float Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0));',\n\t\t\t\t'float alphap = 0.006 * sqrt(Omega);',\n\t\t\t\t'float Bl = 0.5 * alphap * cp / c * Fp;',\n\n\t\t\t\t'float z0 = 0.000037 * square(l_wind) / G * pow(l_wind / cp, 0.9);',\n\t\t\t\t'float uStar = 0.41 * l_wind / log(10.0 / z0);',\n\t\t\t\t'float alpham = 0.01 * ((uStar < CM) ? (1.0 + log(uStar / CM)) : (1.0 + 3.0 * log(uStar / CM)));',\n\t\t\t\t'float Fm = exp(-0.25 * square(k / KM - 1.0));',\n\t\t\t\t'float Bh = 0.5 * alpham * CM / c * Fm * Lpm;',\n\n\t\t\t\t'float a0 = log(2.0) / 4.0;',\n\t\t\t\t'float am = 0.13 * uStar / CM;',\n\t\t\t\t'float Delta = tanh(a0 + 4.0 * pow(c / cp, 2.5) + am * pow(CM / c, 2.5));',\n\n\t\t\t\t'float cosPhi = dot(normalize(u_wind), normalize(K));',\n\n\t\t\t\t'float S = (1.0 / (2.0 * PI)) * pow(k, -4.0) * (Bl + Bh) * (1.0 + Delta * (2.0 * cosPhi * cosPhi - 1.0));',\n\n\t\t\t\t'float dk = 2.0 * PI / u_size;',\n\t\t\t\t'float h = sqrt(S / 2.0) * dk;',\n\n\t\t\t\t'if (K.x == 0.0 && K.y == 0.0) {',\n\t\t\t\t\t'h = 0.0;', //no DC term\n\t\t\t\t'}',\n\t\t\t\t'gl_FragColor = vec4(h, 0.0, 0.0, 0.0);',\n\t\t\t'}'\n\t\t].join( '\\n' )\n\t};\n\tTHREE.ShaderLib[ 'ocean_phase' ] = {\n\t\tuniforms: {\n\t\t\t\"u_phases\": { type: \"t\", value: null },\n\t\t\t\"u_deltaTime\": { type: \"f\", value: null },\n\t\t\t\"u_resolution\": { type: \"f\", value: null },\n\t\t\t\"u_size\": { type: \"f\", value: null },\n\t\t},\n\t\tvarying: {\n\t\t\t\"vUV\": { type: \"v2\" }\n\t\t},\n\t\tfragmentShader: [\n\t\t\t'precision highp float;',\n\n\t\t\t'const float PI = 3.14159265359;',\n\t\t\t'const float G = 9.81;',\n\t\t\t'const float KM = 370.0;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'uniform sampler2D u_phases;',\n\t\t\t'uniform float u_deltaTime;',\n\t\t\t'uniform float u_resolution;',\n\t\t\t'uniform float u_size;',\n\n\t\t\t'float omega (float k) {',\n\t\t\t\t'return sqrt(G * k * (1.0 + k * k / KM * KM));',\n\t\t\t'}',\n\n\t\t\t'void main (void) {',\n\t\t\t\t'float deltaTime = 1.0 / 60.0;',\n\t\t\t\t'vec2 coordinates = gl_FragCoord.xy - 0.5;',\n\t\t\t\t'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;',\n\t\t\t\t'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;',\n\t\t\t\t'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;',\n\n\t\t\t\t'float phase = texture2D(u_phases, vUV).r;',\n\t\t\t\t'float deltaPhase = omega(length(waveVector)) * u_deltaTime;',\n\t\t\t\t'phase = mod(phase + deltaPhase, 2.0 * PI);',\n\n\t\t\t\t'gl_FragColor = vec4(phase, 0.0, 0.0, 0.0);',\n\t\t\t'}'\n\t\t].join( '\\n' )\n\t};\n\tTHREE.ShaderLib[ 'ocean_spectrum' ] = {\n\t\tuniforms: {\n\t\t\t\"u_size\": { type: \"f\", value: null },\n\t\t\t\"u_resolution\": { type: \"f\", value: null },\n\t\t\t\"u_choppiness\": { type: \"f\", value: null },\n\t\t\t\"u_phases\": { type: \"t\", value: null },\n\t\t\t\"u_initialSpectrum\": { type: \"t\", value: null },\n\t\t},\n\t\tvarying: {\n\t\t\t\"vUV\": { type: \"v2\" }\n\t\t},\n\t\tfragmentShader: [\n\t\t\t'precision highp float;',\n\n\t\t\t'const float PI = 3.14159265359;',\n\t\t\t'const float G = 9.81;',\n\t\t\t'const float KM = 370.0;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'uniform float u_size;',\n\t\t\t'uniform float u_resolution;',\n\t\t\t'uniform float u_choppiness;',\n\t\t\t'uniform sampler2D u_phases;',\n\t\t\t'uniform sampler2D u_initialSpectrum;',\n\n\t\t\t'vec2 multiplyComplex (vec2 a, vec2 b) {',\n\t\t\t\t'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);',\n\t\t\t'}',\n\n\t\t\t'vec2 multiplyByI (vec2 z) {',\n\t\t\t\t'return vec2(-z[1], z[0]);',\n\t\t\t'}',\n\n\t\t\t'float omega (float k) {',\n\t\t\t\t'return sqrt(G * k * (1.0 + k * k / KM * KM));',\n\t\t\t'}',\n\n\t\t\t'void main (void) {',\n\t\t\t\t'vec2 coordinates = gl_FragCoord.xy - 0.5;',\n\t\t\t\t'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;',\n\t\t\t\t'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;',\n\t\t\t\t'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;',\n\n\t\t\t\t'float phase = texture2D(u_phases, vUV).r;',\n\t\t\t\t'vec2 phaseVector = vec2(cos(phase), sin(phase));',\n\n\t\t\t\t'vec2 h0 = texture2D(u_initialSpectrum, vUV).rg;',\n\t\t\t\t'vec2 h0Star = texture2D(u_initialSpectrum, vec2(1.0 - vUV + 1.0 / u_resolution)).rg;',\n\t\t\t\t'h0Star.y *= -1.0;',\n\n\t\t\t\t'vec2 h = multiplyComplex(h0, phaseVector) + multiplyComplex(h0Star, vec2(phaseVector.x, -phaseVector.y));',\n\n\t\t\t\t'vec2 hX = -multiplyByI(h * (waveVector.x / length(waveVector))) * u_choppiness;',\n\t\t\t\t'vec2 hZ = -multiplyByI(h * (waveVector.y / length(waveVector))) * u_choppiness;',\n\n\t\t\t\t//no DC term\n\t\t\t\t'if (waveVector.x == 0.0 && waveVector.y == 0.0) {',\n\t\t\t\t\t'h = vec2(0.0);',\n\t\t\t\t\t'hX = vec2(0.0);',\n\t\t\t\t\t'hZ = vec2(0.0);',\n\t\t\t\t'}',\n\n\t\t\t\t'gl_FragColor = vec4(hX + multiplyByI(h), hZ);',\n\t\t\t'}'\n\t\t].join( '\\n' )\n\t};\n\tTHREE.ShaderLib[ 'ocean_normals' ] = {\n\t\tuniforms: {\n\t\t\t\"u_displacementMap\": { type: \"t\", value: null },\n\t\t\t\"u_resolution\": { type: \"f\", value: null },\n\t\t\t\"u_size\": { type: \"f\", value: null },\n\t\t},\n\t\tvarying: {\n\t\t\t\"vUV\": { type: \"v2\" }\n\t\t},\n\t\tfragmentShader: [\n\t\t\t'precision highp float;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'uniform sampler2D u_displacementMap;',\n\t\t\t'uniform float u_resolution;',\n\t\t\t'uniform float u_size;',\n\n\t\t\t'void main (void) {',\n\t\t\t\t'float texel = 1.0 / u_resolution;',\n\t\t\t\t'float texelSize = u_size / u_resolution;',\n\n\t\t\t\t'vec3 center = texture2D(u_displacementMap, vUV).rgb;',\n\t\t\t\t'vec3 right = vec3(texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(texel, 0.0)).rgb - center;',\n\t\t\t\t'vec3 left = vec3(-texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(-texel, 0.0)).rgb - center;',\n\t\t\t\t'vec3 top = vec3(0.0, 0.0, -texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, -texel)).rgb - center;',\n\t\t\t\t'vec3 bottom = vec3(0.0, 0.0, texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, texel)).rgb - center;',\n\n\t\t\t\t'vec3 topRight = cross(right, top);',\n\t\t\t\t'vec3 topLeft = cross(top, left);',\n\t\t\t\t'vec3 bottomLeft = cross(left, bottom);',\n\t\t\t\t'vec3 bottomRight = cross(bottom, right);',\n\n\t\t\t\t'gl_FragColor = vec4(normalize(topRight + topLeft + bottomLeft + bottomRight), 1.0);',\n\t\t\t'}'\n\t\t].join( '\\n' )\n\t};\n\tTHREE.ShaderLib[ 'ocean_main' ] = {\n\t\tuniforms: {\n\t\t\t\"u_displacementMap\": { type: \"t\", value: null },\n\t\t\t\"u_normalMap\": { type: \"t\", value: null },\n\t\t\t\"u_geometrySize\": { type: \"f\", value: null },\n\t\t\t\"u_size\": { type: \"f\", value: null },\n\t\t\t\"u_projectionMatrix\": { type: \"m4\", value: null },\n\t\t\t\"u_viewMatrix\": { type: \"m4\", value: null },\n\t\t\t\"u_cameraPosition\": { type: \"v3\", value: null },\n\t\t\t\"u_skyColor\": { type: \"v3\", value: null },\n\t\t\t\"u_oceanColor\": { type: \"v3\", value: null },\n\t\t\t\"u_sunDirection\": { type: \"v3\", value: null },\n\t\t\t\"u_exposure\": { type: \"f\", value: null },\n\t\t},\n\t\tvarying: {\n\t\t\t\"vPos\": { type: \"v3\" },\n\t\t\t\"vUV\": { type: \"v2\" }\n\t\t},\n\t\tvertexShader: [\n\t\t\t'precision highp float;',\n\n\t\t\t'varying vec3 vPos;',\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'uniform mat4 u_projectionMatrix;',\n\t\t\t'uniform mat4 u_viewMatrix;',\n\t\t\t'uniform float u_size;',\n\t\t\t'uniform float u_geometrySize;',\n\t\t\t'uniform sampler2D u_displacementMap;',\n\n\t\t\t'void main (void) {',\n\t\t\t\t'vec3 newPos = position + texture2D(u_displacementMap, uv).rgb * (u_geometrySize / u_size);',\n\t\t\t\t'vPos = newPos;',\n\t\t\t\t'vUV = uv;',\n\t\t\t\t'gl_Position = u_projectionMatrix * u_viewMatrix * vec4(newPos, 1.0);',\n\t\t\t'}'\n\t\t].join( '\\n' ),\n\t\tfragmentShader: [\n\t\t\t'precision highp float;',\n\n\t\t\t'varying vec3 vPos;',\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'uniform sampler2D u_displacementMap;',\n\t\t\t'uniform sampler2D u_normalMap;',\n\t\t\t'uniform vec3 u_cameraPosition;',\n\t\t\t'uniform vec3 u_oceanColor;',\n\t\t\t'uniform vec3 u_skyColor;',\n\t\t\t'uniform vec3 u_sunDirection;',\n\t\t\t'uniform float u_exposure;',\n\n\t\t\t'vec3 hdr (vec3 color, float exposure) {',\n\t\t\t\t'return 1.0 - exp(-color * exposure);',\n\t\t\t'}',\n\n\t\t\t'void main (void) {',\n\t\t\t\t'vec3 normal = texture2D(u_normalMap, vUV).rgb;',\n\n\t\t\t\t'vec3 view = normalize(u_cameraPosition - vPos);',\n\t\t\t\t'float fresnel = 0.02 + 0.98 * pow(1.0 - dot(normal, view), 5.0);',\n\t\t\t\t'vec3 sky = fresnel * u_skyColor;',\n\n\t\t\t\t'float diffuse = clamp(dot(normal, normalize(u_sunDirection)), 0.0, 1.0);',\n\t\t\t\t'vec3 water = (1.0 - fresnel) * u_oceanColor * u_skyColor * diffuse;',\n\n\t\t\t\t'vec3 color = sky + water;',\n\n\t\t\t\t'gl_FragColor = vec4(hdr(color, u_exposure), 1.0);',\n\t\t\t'}'\n\t\t].join( '\\n' )\n\t};\n\n}\n"]},"metadata":{},"sourceType":"script"}