{"ast":null,"code":"module.exports = function (THREE) {\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   *\n   * Convolution shader\n   * ported from o3d sample to WebGL / GLSL\n   * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n   */\n  THREE.ConvolutionShader = {\n    defines: {\n      \"KERNEL_SIZE_FLOAT\": \"25.0\",\n      \"KERNEL_SIZE_INT\": \"25\"\n    },\n    uniforms: {\n      \"tDiffuse\": {\n        type: \"t\",\n        value: null\n      },\n      \"uImageIncrement\": {\n        type: \"v2\",\n        value: new THREE.Vector2(0.001953125, 0.0)\n      },\n      \"cKernel\": {\n        type: \"fv1\",\n        value: []\n      }\n    },\n    vertexShader: [\"uniform vec2 uImageIncrement;\", \"varying vec2 vUv;\", \"void main() {\", \"vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform float cKernel[ KERNEL_SIZE_INT ];\", \"uniform sampler2D tDiffuse;\", \"uniform vec2 uImageIncrement;\", \"varying vec2 vUv;\", \"void main() {\", \"vec2 imageCoord = vUv;\", \"vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\", \"for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\", \"sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\", \"imageCoord += uImageIncrement;\", \"}\", \"gl_FragColor = sum;\", \"}\"].join(\"\\n\"),\n    buildKernel: function (sigma) {\n      // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n      function gauss(x, sigma) {\n        return Math.exp(-(x * x) / (2.0 * sigma * sigma));\n      }\n\n      var i,\n          values,\n          sum,\n          halfWidth,\n          kMaxKernelSize = 25,\n          kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;\n      if (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;\n      halfWidth = (kernelSize - 1) * 0.5;\n      values = new Array(kernelSize);\n      sum = 0.0;\n\n      for (i = 0; i < kernelSize; ++i) {\n        values[i] = gauss(i - halfWidth, sigma);\n        sum += values[i];\n      } // normalize the kernel\n\n\n      for (i = 0; i < kernelSize; ++i) values[i] /= sum;\n\n      return values;\n    }\n  };\n};","map":{"version":3,"sources":["E:/baking/hongpeibang/node_modules/three-js/addons/ConvolutionShader.js"],"names":["module","exports","THREE","ConvolutionShader","defines","uniforms","type","value","Vector2","vertexShader","join","fragmentShader","buildKernel","sigma","gauss","x","Math","exp","i","values","sum","halfWidth","kMaxKernelSize","kernelSize","ceil","Array"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiB,UAAUC,KAAV,EAAiB;AACjC;;;;;;;AAQAA,EAAAA,KAAK,CAACC,iBAAN,GAA0B;AAEzBC,IAAAA,OAAO,EAAE;AAER,2BAAqB,MAFb;AAGR,yBAAmB;AAHX,KAFgB;AASzBC,IAAAA,QAAQ,EAAE;AAET,kBAAmB;AAAEC,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAFV;AAGT,yBAAmB;AAAED,QAAAA,IAAI,EAAE,IAAR;AAAcC,QAAAA,KAAK,EAAE,IAAIL,KAAK,CAACM,OAAV,CAAmB,WAAnB,EAAgC,GAAhC;AAArB,OAHV;AAIT,iBAAmB;AAAEF,QAAAA,IAAI,EAAE,KAAR;AAAeC,QAAAA,KAAK,EAAE;AAAtB;AAJV,KATe;AAiBzBE,IAAAA,YAAY,EAAE,CAEb,+BAFa,EAIb,mBAJa,EAMb,eANa,EAQZ,qEARY,EASZ,2EATY,EAWb,GAXa,EAaZC,IAbY,CAaN,IAbM,CAjBW;AAgCzBC,IAAAA,cAAc,EAAE,CAEf,2CAFe,EAIf,6BAJe,EAKf,+BALe,EAOf,mBAPe,EASf,eATe,EAWd,wBAXc,EAYd,wCAZc,EAcd,+CAdc,EAgBb,0DAhBa,EAiBb,gCAjBa,EAmBd,GAnBc,EAqBd,qBArBc,EAuBf,GAvBe,EA0BdD,IA1Bc,CA0BR,IA1BQ,CAhCS;AA4DzBE,IAAAA,WAAW,EAAE,UAAWC,KAAX,EAAmB;AAE/B;AAEA,eAASC,KAAT,CAAgBC,CAAhB,EAAmBF,KAAnB,EAA2B;AAE1B,eAAOG,IAAI,CAACC,GAAL,CAAU,EAAIF,CAAC,GAAGA,CAAR,KAAgB,MAAMF,KAAN,GAAcA,KAA9B,CAAV,CAAP;AAEA;;AAED,UAAIK,CAAJ;AAAA,UAAOC,MAAP;AAAA,UAAeC,GAAf;AAAA,UAAoBC,SAApB;AAAA,UAA+BC,cAAc,GAAG,EAAhD;AAAA,UAAoDC,UAAU,GAAG,IAAIP,IAAI,CAACQ,IAAL,CAAWX,KAAK,GAAG,GAAnB,CAAJ,GAA+B,CAAhG;AAEA,UAAKU,UAAU,GAAGD,cAAlB,EAAmCC,UAAU,GAAGD,cAAb;AACnCD,MAAAA,SAAS,GAAG,CAAEE,UAAU,GAAG,CAAf,IAAqB,GAAjC;AAEAJ,MAAAA,MAAM,GAAG,IAAIM,KAAJ,CAAWF,UAAX,CAAT;AACAH,MAAAA,GAAG,GAAG,GAAN;;AACA,WAAMF,CAAC,GAAG,CAAV,EAAaA,CAAC,GAAGK,UAAjB,EAA6B,EAAGL,CAAhC,EAAoC;AAEnCC,QAAAA,MAAM,CAAED,CAAF,CAAN,GAAcJ,KAAK,CAAEI,CAAC,GAAGG,SAAN,EAAiBR,KAAjB,CAAnB;AACAO,QAAAA,GAAG,IAAID,MAAM,CAAED,CAAF,CAAb;AAEA,OAtB8B,CAwB/B;;;AAEA,WAAMA,CAAC,GAAG,CAAV,EAAaA,CAAC,GAAGK,UAAjB,EAA6B,EAAGL,CAAhC,EAAoCC,MAAM,CAAED,CAAF,CAAN,IAAeE,GAAf;;AAEpC,aAAOD,MAAP;AAEA;AA1FwB,GAA1B;AA8FA,CAvGD","sourcesContent":["module.exports = function( THREE ){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Convolution shader\n\t * ported from o3d sample to WebGL / GLSL\n\t * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n\t */\n\n\tTHREE.ConvolutionShader = {\n\n\t\tdefines: {\n\n\t\t\t\"KERNEL_SIZE_FLOAT\": \"25.0\",\n\t\t\t\"KERNEL_SIZE_INT\": \"25\",\n\n\t\t},\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\":        { type: \"t\", value: null },\n\t\t\t\"uImageIncrement\": { type: \"v2\", value: new THREE.Vector2( 0.001953125, 0.0 ) },\n\t\t\t\"cKernel\":         { type: \"fv1\", value: [] }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform vec2 uImageIncrement;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\",\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float cKernel[ KERNEL_SIZE_INT ];\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform vec2 uImageIncrement;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vec2 imageCoord = vUv;\",\n\t\t\t\t\"vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\",\n\n\t\t\t\t\"for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\",\n\n\t\t\t\t\t\"sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\",\n\t\t\t\t\t\"imageCoord += uImageIncrement;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"gl_FragColor = sum;\",\n\n\t\t\t\"}\"\n\n\n\t\t].join( \"\\n\" ),\n\n\t\tbuildKernel: function ( sigma ) {\n\n\t\t\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n\n\t\t\tfunction gauss( x, sigma ) {\n\n\t\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );\n\n\t\t\t}\n\n\t\t\tvar i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;\n\n\t\t\tif ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;\n\t\t\thalfWidth = ( kernelSize - 1 ) * 0.5;\n\n\t\t\tvalues = new Array( kernelSize );\n\t\t\tsum = 0.0;\n\t\t\tfor ( i = 0; i < kernelSize; ++ i ) {\n\n\t\t\t\tvalues[ i ] = gauss( i - halfWidth, sigma );\n\t\t\t\tsum += values[ i ];\n\n\t\t\t}\n\n\t\t\t// normalize the kernel\n\n\t\t\tfor ( i = 0; i < kernelSize; ++ i ) values[ i ] /= sum;\n\n\t\t\treturn values;\n\n\t\t}\n\n\t};\n\n}\n"]},"metadata":{},"sourceType":"script"}