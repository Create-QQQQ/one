{"ast":null,"code":"module.exports = function (THREE) {\n  /**\n   * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog\n   *\n   * Edge Detection Shader using Frei-Chen filter\n   * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector\n   *\n   * aspect: vec2 of (1/width, 1/height)\n   */\n  THREE.EdgeShader = {\n    uniforms: {\n      \"tDiffuse\": {\n        type: \"t\",\n        value: null\n      },\n      \"aspect\": {\n        type: \"v2\",\n        value: new THREE.Vector2(512, 512)\n      }\n    },\n    vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"uniform vec2 aspect;\", \"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\", \"mat3 G[9];\", // hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\n    \"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\", \"const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\", \"const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\", \"const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\", \"const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\", \"const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\", \"const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\", \"const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\", \"const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\", \"void main(void)\", \"{\", \"G[0] = g0,\", \"G[1] = g1,\", \"G[2] = g2,\", \"G[3] = g3,\", \"G[4] = g4,\", \"G[5] = g5,\", \"G[6] = g6,\", \"G[7] = g7,\", \"G[8] = g8;\", \"mat3 I;\", \"float cnv[9];\", \"vec3 sample;\",\n    /* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n    \"for (float i=0.0; i<3.0; i++) {\", \"for (float j=0.0; j<3.0; j++) {\", \"sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\", \"I[int(i)][int(j)] = length(sample);\", \"}\", \"}\",\n    /* calculate the convolution values for all the masks */\n    \"for (int i=0; i<9; i++) {\", \"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\", \"cnv[i] = dp3 * dp3;\", \"}\", \"float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\", \"float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\", \"gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);\", \"}\"].join(\"\\n\")\n  };\n};","map":{"version":3,"sources":["E:/baking/hongpeibang/node_modules/three-js/addons/EdgeShader.js"],"names":["module","exports","THREE","EdgeShader","uniforms","type","value","Vector2","vertexShader","join","fragmentShader"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiB,UAAUC,KAAV,EAAiB;AACjC;;;;;;;;AASAA,EAAAA,KAAK,CAACC,UAAN,GAAmB;AAElBC,IAAAA,QAAQ,EAAE;AAET,kBAAY;AAAEC,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAFH;AAGT,gBAAa;AAAED,QAAAA,IAAI,EAAE,IAAR;AAAcC,QAAAA,KAAK,EAAE,IAAIJ,KAAK,CAACK,OAAV,CAAmB,GAAnB,EAAwB,GAAxB;AAArB;AAHJ,KAFQ;AAQlBC,IAAAA,YAAY,EAAE,CAEb,mBAFa,EAIb,eAJa,EAMZ,WANY,EAOZ,2EAPY,EASb,GATa,EAWZC,IAXY,CAWN,IAXM,CARI;AAqBlBC,IAAAA,cAAc,EAAE,CAEf,6BAFe,EAGf,mBAHe,EAKf,sBALe,EAOf,oDAPe,EAUf,YAVe,EAYf;AAEA,mIAde,EAef,+HAfe,EAgBf,+HAhBe,EAiBf,+HAjBe,EAkBf,8DAlBe,EAmBf,8DAnBe,EAoBf,iNApBe,EAqBf,iNArBe,EAsBf,6MAtBe,EAwBf,iBAxBe,EAyBf,GAzBe,EA2Bd,YA3Bc,EA4Bd,YA5Bc,EA6Bd,YA7Bc,EA8Bd,YA9Bc,EA+Bd,YA/Bc,EAgCd,YAhCc,EAiCd,YAjCc,EAkCd,YAlCc,EAmCd,YAnCc,EAqCd,SArCc,EAsCd,eAtCc,EAuCd,cAvCc;AAyCd;AACA,qCA1Cc,EA2Cb,iCA3Ca,EA4CZ,qEA5CY,EA6CZ,qCA7CY,EA8Cb,GA9Ca,EA+Cd,GA/Cc;AAiDd;AACA,+BAlDc,EAmDb,2EAnDa,EAoDb,qBApDa,EAqDd,GArDc,EAuDd,kDAvDc,EAwDd,iEAxDc,EA0Dd,4CA1Dc,EA2Df,GA3De,EA6DdD,IA7Dc,CA6DR,IA7DQ;AArBE,GAAnB;AAqFA,CA/FD","sourcesContent":["module.exports = function( THREE ){\n\t/**\n\t * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog\n\t *\n\t * Edge Detection Shader using Frei-Chen filter\n\t * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector\n\t *\n\t * aspect: vec2 of (1/width, 1/height)\n\t */\n\n\tTHREE.EdgeShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\t\"aspect\":    { type: \"v2\", value: new THREE.Vector2( 512, 512 ) },\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vUv = uv;\",\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"uniform vec2 aspect;\",\n\n\t\t\t\"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\",\n\n\n\t\t\t\"mat3 G[9];\",\n\n\t\t\t// hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\n\n\t\t\t\"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\",\n\t\t\t\"const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\",\n\t\t\t\"const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\",\n\t\t\t\"const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\",\n\t\t\t\"const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\",\n\t\t\t\"const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\",\n\t\t\t\"const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\",\n\t\t\t\"const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\",\n\t\t\t\"const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\",\n\n\t\t\t\"void main(void)\",\n\t\t\t\"{\",\n\n\t\t\t\t\"G[0] = g0,\",\n\t\t\t\t\"G[1] = g1,\",\n\t\t\t\t\"G[2] = g2,\",\n\t\t\t\t\"G[3] = g3,\",\n\t\t\t\t\"G[4] = g4,\",\n\t\t\t\t\"G[5] = g5,\",\n\t\t\t\t\"G[6] = g6,\",\n\t\t\t\t\"G[7] = g7,\",\n\t\t\t\t\"G[8] = g8;\",\n\n\t\t\t\t\"mat3 I;\",\n\t\t\t\t\"float cnv[9];\",\n\t\t\t\t\"vec3 sample;\",\n\n\t\t\t\t/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n\t\t\t\t\"for (float i=0.0; i<3.0; i++) {\",\n\t\t\t\t\t\"for (float j=0.0; j<3.0; j++) {\",\n\t\t\t\t\t\t\"sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\",\n\t\t\t\t\t\t\"I[int(i)][int(j)] = length(sample);\",\n\t\t\t\t\t\"}\",\n\t\t\t\t\"}\",\n\n\t\t\t\t/* calculate the convolution values for all the masks */\n\t\t\t\t\"for (int i=0; i<9; i++) {\",\n\t\t\t\t\t\"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\",\n\t\t\t\t\t\"cnv[i] = dp3 * dp3;\",\n\t\t\t\t\"}\",\n\n\t\t\t\t\"float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\",\n\t\t\t\t\"float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\",\n\n\t\t\t\t\"gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);\",\n\t\t\t\"}\",\n\n\t\t].join( \"\\n\" )\n\t};\n\n}\n"]},"metadata":{},"sourceType":"script"}