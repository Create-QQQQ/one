{"ast":null,"code":"module.exports = function (THREE) {\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   *\n   * Based on Nvidia Cg tutorial\n   */\n  THREE.FresnelShader = {\n    uniforms: {\n      \"mRefractionRatio\": {\n        type: \"f\",\n        value: 1.02\n      },\n      \"mFresnelBias\": {\n        type: \"f\",\n        value: 0.1\n      },\n      \"mFresnelPower\": {\n        type: \"f\",\n        value: 2.0\n      },\n      \"mFresnelScale\": {\n        type: \"f\",\n        value: 1.0\n      },\n      \"tCube\": {\n        type: \"t\",\n        value: null\n      }\n    },\n    vertexShader: [\"uniform float mRefractionRatio;\", \"uniform float mFresnelBias;\", \"uniform float mFresnelScale;\", \"uniform float mFresnelPower;\", \"varying vec3 vReflect;\", \"varying vec3 vRefract[3];\", \"varying float vReflectionFactor;\", \"void main() {\", \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\", \"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\", \"vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\", \"vec3 I = worldPosition.xyz - cameraPosition;\", \"vReflect = reflect( I, worldNormal );\", \"vRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );\", \"vRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );\", \"vRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );\", \"vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );\", \"gl_Position = projectionMatrix * mvPosition;\", \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform samplerCube tCube;\", \"varying vec3 vReflect;\", \"varying vec3 vRefract[3];\", \"varying float vReflectionFactor;\", \"void main() {\", \"vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\", \"vec4 refractedColor = vec4( 1.0 );\", \"refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\", \"refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\", \"refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\", \"gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\", \"}\"].join(\"\\n\")\n  };\n};","map":{"version":3,"sources":["E:/baking/hongpeibang/node_modules/three-js/addons/FresnelShader.js"],"names":["module","exports","THREE","FresnelShader","uniforms","type","value","vertexShader","join","fragmentShader"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiB,UAAUC,KAAV,EAAiB;AACjC;;;;;AAMAA,EAAAA,KAAK,CAACC,aAAN,GAAsB;AAErBC,IAAAA,QAAQ,EAAE;AAET,0BAAoB;AAAEC,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAFX;AAGT,sBAAgB;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAHP;AAIT,uBAAiB;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAJR;AAKT,uBAAiB;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OALR;AAMT,eAAS;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB;AANA,KAFW;AAYrBC,IAAAA,YAAY,EAAE,CAEb,iCAFa,EAGb,6BAHa,EAIb,8BAJa,EAKb,8BALa,EAOb,wBAPa,EAQb,2BARa,EASb,kCATa,EAWb,eAXa,EAaZ,4DAbY,EAcZ,2DAdY,EAgBZ,8GAhBY,EAkBZ,8CAlBY,EAoBZ,uCApBY,EAqBZ,yEArBY,EAsBZ,gFAtBY,EAuBZ,gFAvBY,EAwBZ,oHAxBY,EA0BZ,8CA1BY,EA4Bb,GA5Ba,EA8BZC,IA9BY,CA8BN,IA9BM,CAZO;AA4CrBC,IAAAA,cAAc,EAAE,CAEf,4BAFe,EAIf,wBAJe,EAKf,2BALe,EAMf,kCANe,EAQf,eARe,EAUd,+EAVc,EAWd,oCAXc,EAad,oFAbc,EAcd,oFAdc,EAed,oFAfc,EAiBd,6FAjBc,EAmBf,GAnBe,EAqBdD,IArBc,CAqBR,IArBQ;AA5CK,GAAtB;AAqEA,CA5ED","sourcesContent":["module.exports = function( THREE ){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Based on Nvidia Cg tutorial\n\t */\n\n\tTHREE.FresnelShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"mRefractionRatio\": { type: \"f\", value: 1.02 },\n\t\t\t\"mFresnelBias\": { type: \"f\", value: 0.1 },\n\t\t\t\"mFresnelPower\": { type: \"f\", value: 2.0 },\n\t\t\t\"mFresnelScale\": { type: \"f\", value: 1.0 },\n\t\t\t\"tCube\": { type: \"t\", value: null }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform float mRefractionRatio;\",\n\t\t\t\"uniform float mFresnelBias;\",\n\t\t\t\"uniform float mFresnelScale;\",\n\t\t\t\"uniform float mFresnelPower;\",\n\n\t\t\t\"varying vec3 vReflect;\",\n\t\t\t\"varying vec3 vRefract[3];\",\n\t\t\t\"varying float vReflectionFactor;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\t\"vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\",\n\n\t\t\t\t\"vec3 I = worldPosition.xyz - cameraPosition;\",\n\n\t\t\t\t\"vReflect = reflect( I, worldNormal );\",\n\t\t\t\t\"vRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );\",\n\t\t\t\t\"vRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );\",\n\t\t\t\t\"vRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );\",\n\t\t\t\t\"vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform samplerCube tCube;\",\n\n\t\t\t\"varying vec3 vReflect;\",\n\t\t\t\"varying vec3 vRefract[3];\",\n\t\t\t\"varying float vReflectionFactor;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\",\n\t\t\t\t\"vec4 refractedColor = vec4( 1.0 );\",\n\n\t\t\t\t\"refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\",\n\t\t\t\t\"refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\",\n\t\t\t\t\"refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\",\n\n\t\t\t\t\"gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\n}\n"]},"metadata":{},"sourceType":"script"}