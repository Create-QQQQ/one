{"ast":null,"code":"module.exports = function (THREE) {\n  // Parallax Occlusion shaders from\n  //    http://sunandblackcat.com/tipFullView.php?topicid=28\n  // No tangent-space transforms logic based on\n  //   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html\n  THREE.ParallaxShader = {\n    // Ordered from fastest to best quality.\n    modes: {\n      none: 'NO_PARALLAX',\n      basic: 'USE_BASIC_PARALLAX',\n      steep: 'USE_STEEP_PARALLAX',\n      occlusion: 'USE_OCLUSION_PARALLAX',\n      // a.k.a. POM\n      relief: 'USE_RELIEF_PARALLAX'\n    },\n    uniforms: {\n      \"bumpMap\": {\n        type: \"t\",\n        value: null\n      },\n      \"map\": {\n        type: \"t\",\n        value: null\n      },\n      \"parallaxScale\": {\n        type: \"f\",\n        value: null\n      },\n      \"parallaxMinLayers\": {\n        type: \"f\",\n        value: null\n      },\n      \"parallaxMaxLayers\": {\n        type: \"f\",\n        value: null\n      }\n    },\n    vertexShader: [\"varying vec2 vUv;\", \"varying vec3 vViewPosition;\", \"varying vec3 vNormal;\", \"void main() {\", \"vUv = uv;\", \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\", \"vViewPosition = -mvPosition.xyz;\", \"vNormal = normalize( normalMatrix * normal );\", \"gl_Position = projectionMatrix * mvPosition;\", \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform sampler2D bumpMap;\", \"uniform sampler2D map;\", \"uniform float parallaxScale;\", \"uniform float parallaxMinLayers;\", \"uniform float parallaxMaxLayers;\", \"varying vec2 vUv;\", \"varying vec3 vViewPosition;\", \"varying vec3 vNormal;\", \"#ifdef USE_BASIC_PARALLAX\", \"vec2 parallaxMap( in vec3 V ) {\", \"float initialHeight = texture2D( bumpMap, vUv ).r;\", // No Offset Limitting: messy, floating output at grazing angles.\n    //\"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\",\n    // Offset Limiting\n    \"vec2 texCoordOffset = parallaxScale * V.xy * initialHeight;\", \"return vUv - texCoordOffset;\", \"}\", \"#else\", \"vec2 parallaxMap( in vec3 V ) {\", // Determine number of layers from angle between V and N\n    \"float numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );\", \"float layerHeight = 1.0 / numLayers;\", \"float currentLayerHeight = 0.0;\", // Shift of texture coordinates for each iteration\n    \"vec2 dtex = parallaxScale * V.xy / V.z / numLayers;\", \"vec2 currentTextureCoords = vUv;\", \"float heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\", // while ( heightFromTexture > currentLayerHeight )\n    // Infinite loops are not well supported. Do a \"large\" finite\n    // loop, but not too large, as it slows down some compilers.\n    \"for ( int i = 0; i < 30; i += 1 ) {\", \"if ( heightFromTexture <= currentLayerHeight ) {\", \"break;\", \"}\", \"currentLayerHeight += layerHeight;\", // Shift texture coordinates along vector V\n    \"currentTextureCoords -= dtex;\", \"heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\", \"}\", \"#ifdef USE_STEEP_PARALLAX\", \"return currentTextureCoords;\", \"#elif defined( USE_RELIEF_PARALLAX )\", \"vec2 deltaTexCoord = dtex / 2.0;\", \"float deltaHeight = layerHeight / 2.0;\", // Return to the mid point of previous layer\n    \"currentTextureCoords += deltaTexCoord;\", \"currentLayerHeight -= deltaHeight;\", // Binary search to increase precision of Steep Parallax Mapping\n    \"const int numSearches = 5;\", \"for ( int i = 0; i < numSearches; i += 1 ) {\", \"deltaTexCoord /= 2.0;\", \"deltaHeight /= 2.0;\", \"heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\", // Shift along or against vector V\n    \"if( heightFromTexture > currentLayerHeight ) {\", // Below the surface\n    \"currentTextureCoords -= deltaTexCoord;\", \"currentLayerHeight += deltaHeight;\", \"} else {\", // above the surface\n    \"currentTextureCoords += deltaTexCoord;\", \"currentLayerHeight -= deltaHeight;\", \"}\", \"}\", \"return currentTextureCoords;\", \"#elif defined( USE_OCLUSION_PARALLAX )\", \"vec2 prevTCoords = currentTextureCoords + dtex;\", // Heights for linear interpolation\n    \"float nextH = heightFromTexture - currentLayerHeight;\", \"float prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;\", // Proportions for linear interpolation\n    \"float weight = nextH / ( nextH - prevH );\", // Interpolation of texture coordinates\n    \"return prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );\", \"#else\", // NO_PARALLAX\n    \"return vUv;\", \"#endif\", \"}\", \"#endif\", \"vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {\", \"vec2 texDx = dFdx( vUv );\", \"vec2 texDy = dFdy( vUv );\", \"vec3 vSigmaX = dFdx( surfPosition );\", \"vec3 vSigmaY = dFdy( surfPosition );\", \"vec3 vR1 = cross( vSigmaY, surfNormal );\", \"vec3 vR2 = cross( surfNormal, vSigmaX );\", \"float fDet = dot( vSigmaX, vR1 );\", \"vec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );\", \"vec3 vProjVtex;\", \"vProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;\", \"vProjVtex.z = dot( surfNormal, viewPosition );\", \"return parallaxMap( vProjVtex );\", \"}\", \"void main() {\", \"vec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );\", \"gl_FragColor = texture2D( map, mapUv );\", \"}\"].join(\"\\n\")\n  };\n};","map":{"version":3,"sources":["E:/baking/hongpeibang/node_modules/three-js/addons/ParallaxShader.js"],"names":["module","exports","THREE","ParallaxShader","modes","none","basic","steep","occlusion","relief","uniforms","type","value","vertexShader","join","fragmentShader"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiB,UAAUC,KAAV,EAAiB;AACjC;AACA;AACA;AACA;AAEAA,EAAAA,KAAK,CAACC,cAAN,GAAuB;AACtB;AACAC,IAAAA,KAAK,EAAE;AACNC,MAAAA,IAAI,EAAG,aADD;AAENC,MAAAA,KAAK,EAAE,oBAFD;AAGNC,MAAAA,KAAK,EAAE,oBAHD;AAINC,MAAAA,SAAS,EAAE,uBAJL;AAI8B;AACpCC,MAAAA,MAAM,EAAE;AALF,KAFe;AAUtBC,IAAAA,QAAQ,EAAE;AACT,iBAAW;AAAEC,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OADF;AAET,aAAO;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAFE;AAGT,uBAAiB;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAHR;AAIT,2BAAqB;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAJZ;AAKT,2BAAqB;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB;AALZ,KAVY;AAkBtBC,IAAAA,YAAY,EAAE,CACb,mBADa,EAEb,6BAFa,EAGb,uBAHa,EAKb,eALa,EAOZ,WAPY,EAQZ,4DARY,EASZ,kCATY,EAUZ,+CAVY,EAWZ,8CAXY,EAab,GAba,EAeXC,IAfW,CAeL,IAfK,CAlBQ;AAmCtBC,IAAAA,cAAc,EAAE,CACf,4BADe,EAEf,wBAFe,EAIf,8BAJe,EAKf,kCALe,EAMf,kCANe,EAQf,mBARe,EASf,6BATe,EAUf,uBAVe,EAYf,2BAZe,EAcd,iCAdc,EAgBb,oDAhBa,EAkBb;AACA;AAEA;AACA,iEAtBa,EAuBb,8BAvBa,EAyBd,GAzBc,EA2Bf,OA3Be,EA6Bd,iCA7Bc,EA+Bb;AACA,4GAhCa,EAkCb,sCAlCa,EAmCb,iCAnCa,EAoCb;AACA,yDArCa,EAuCb,kCAvCa,EAyCb,yEAzCa,EA2Cb;AACA;AACA;AACA,yCA9Ca,EA+CZ,kDA/CY,EAgDX,QAhDW,EAiDZ,GAjDY,EAkDZ,oCAlDY,EAmDZ;AACA,mCApDY,EAqDZ,mEArDY,EAsDb,GAtDa,EAwDb,2BAxDa,EA0DZ,8BA1DY,EA4Db,sCA5Da,EA8DZ,kCA9DY,EA+DZ,wCA/DY,EAiEZ;AACA,4CAlEY,EAmEZ,oCAnEY,EAqEZ;AACA,gCAtEY,EAuEZ,8CAvEY,EAyEX,uBAzEW,EA0EX,qBA1EW,EA2EX,mEA3EW,EA4EX;AACA,oDA7EW,EA6EuC;AAEjD,4CA/EU,EAgFV,oCAhFU,EAkFX,UAlFW,EAkFC;AAEX,4CApFU,EAqFV,oCArFU,EAuFX,GAvFW,EAyFZ,GAzFY,EA0FZ,8BA1FY,EA4Fb,wCA5Fa,EA8FZ,iDA9FY,EAgGZ;AACA,2DAjGY,EAkGZ,uFAlGY,EAoGZ;AACA,+CArGY,EAuGZ;AACA,4EAxGY,EA0Gb,OA1Ga,EA0GJ;AAER,iBA5GY,EA8Gb,QA9Ga,EAgHd,GAhHc,EAiHf,QAjHe,EAmHf,2EAnHe,EAqHb,2BArHa,EAsHd,2BAtHc,EAwHd,sCAxHc,EAyHd,sCAzHc,EA0Hd,0CA1Hc,EA2Hd,0CA3Hc,EA4Hd,mCA5Hc,EA8Hd,+FA9Hc,EA+Hd,iBA/Hc,EAgId,2DAhIc,EAiId,gDAjIc,EAmId,kCAnIc,EAoIf,GApIe,EAsIf,eAtIe,EAwId,6FAxIc,EAyId,yCAzIc,EA2If,GA3Ie,EA6IbD,IA7Ia,CA6IP,IA7IO;AAnCM,GAAvB;AAoLA,CA1LD","sourcesContent":["module.exports = function( THREE ){\n\t// Parallax Occlusion shaders from\n\t//    http://sunandblackcat.com/tipFullView.php?topicid=28\n\t// No tangent-space transforms logic based on\n\t//   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html\n\n\tTHREE.ParallaxShader = {\n\t\t// Ordered from fastest to best quality.\n\t\tmodes: {\n\t\t\tnone:  'NO_PARALLAX',\n\t\t\tbasic: 'USE_BASIC_PARALLAX',\n\t\t\tsteep: 'USE_STEEP_PARALLAX',\n\t\t\tocclusion: 'USE_OCLUSION_PARALLAX', // a.k.a. POM\n\t\t\trelief: 'USE_RELIEF_PARALLAX',\n\t\t},\n\n\t\tuniforms: {\n\t\t\t\"bumpMap\": { type: \"t\", value: null },\n\t\t\t\"map\": { type: \"t\", value: null },\n\t\t\t\"parallaxScale\": { type: \"f\", value: null },\n\t\t\t\"parallaxMinLayers\": { type: \"f\", value: null },\n\t\t\t\"parallaxMaxLayers\": { type: \"f\", value: null }\n\t\t},\n\n\t\tvertexShader: [\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"varying vec3 vViewPosition;\",\n\t\t\t\"varying vec3 vNormal;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vUv = uv;\",\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\n\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\"}\"\n\n\t  ].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\t\t\t\"uniform sampler2D bumpMap;\",\n\t\t\t\"uniform sampler2D map;\",\n\n\t\t\t\"uniform float parallaxScale;\",\n\t\t\t\"uniform float parallaxMinLayers;\",\n\t\t\t\"uniform float parallaxMaxLayers;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"varying vec3 vViewPosition;\",\n\t\t\t\"varying vec3 vNormal;\",\n\n\t\t\t\"#ifdef USE_BASIC_PARALLAX\",\n\n\t\t\t\t\"vec2 parallaxMap( in vec3 V ) {\",\n\n\t\t\t\t\t\"float initialHeight = texture2D( bumpMap, vUv ).r;\",\n\n\t\t\t\t\t// No Offset Limitting: messy, floating output at grazing angles.\n\t\t\t\t\t//\"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\",\n\n\t\t\t\t\t// Offset Limiting\n\t\t\t\t\t\"vec2 texCoordOffset = parallaxScale * V.xy * initialHeight;\",\n\t\t\t\t\t\"return vUv - texCoordOffset;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"vec2 parallaxMap( in vec3 V ) {\",\n\n\t\t\t\t\t// Determine number of layers from angle between V and N\n\t\t\t\t\t\"float numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );\",\n\n\t\t\t\t\t\"float layerHeight = 1.0 / numLayers;\",\n\t\t\t\t\t\"float currentLayerHeight = 0.0;\",\n\t\t\t\t\t// Shift of texture coordinates for each iteration\n\t\t\t\t\t\"vec2 dtex = parallaxScale * V.xy / V.z / numLayers;\",\n\n\t\t\t\t\t\"vec2 currentTextureCoords = vUv;\",\n\n\t\t\t\t\t\"float heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\",\n\n\t\t\t\t\t// while ( heightFromTexture > currentLayerHeight )\n\t\t\t\t\t// Infinite loops are not well supported. Do a \"large\" finite\n\t\t\t\t\t// loop, but not too large, as it slows down some compilers.\n\t\t\t\t\t\"for ( int i = 0; i < 30; i += 1 ) {\",\n\t\t\t\t\t\t\"if ( heightFromTexture <= currentLayerHeight ) {\",\n\t\t\t\t\t\t\t\"break;\",\n\t\t\t\t\t\t\"}\",\n\t\t\t\t\t\t\"currentLayerHeight += layerHeight;\",\n\t\t\t\t\t\t// Shift texture coordinates along vector V\n\t\t\t\t\t\t\"currentTextureCoords -= dtex;\",\n\t\t\t\t\t\t\"heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\",\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"#ifdef USE_STEEP_PARALLAX\",\n\n\t\t\t\t\t\t\"return currentTextureCoords;\",\n\n\t\t\t\t\t\"#elif defined( USE_RELIEF_PARALLAX )\",\n\n\t\t\t\t\t\t\"vec2 deltaTexCoord = dtex / 2.0;\",\n\t\t\t\t\t\t\"float deltaHeight = layerHeight / 2.0;\",\n\n\t\t\t\t\t\t// Return to the mid point of previous layer\n\t\t\t\t\t\t\"currentTextureCoords += deltaTexCoord;\",\n\t\t\t\t\t\t\"currentLayerHeight -= deltaHeight;\",\n\n\t\t\t\t\t\t// Binary search to increase precision of Steep Parallax Mapping\n\t\t\t\t\t\t\"const int numSearches = 5;\",\n\t\t\t\t\t\t\"for ( int i = 0; i < numSearches; i += 1 ) {\",\n\n\t\t\t\t\t\t\t\"deltaTexCoord /= 2.0;\",\n\t\t\t\t\t\t\t\"deltaHeight /= 2.0;\",\n\t\t\t\t\t\t\t\"heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\",\n\t\t\t\t\t\t\t// Shift along or against vector V\n\t\t\t\t\t\t\t\"if( heightFromTexture > currentLayerHeight ) {\", // Below the surface\n\n\t\t\t\t\t\t\t\t\"currentTextureCoords -= deltaTexCoord;\",\n\t\t\t\t\t\t\t\t\"currentLayerHeight += deltaHeight;\",\n\n\t\t\t\t\t\t\t\"} else {\", // above the surface\n\n\t\t\t\t\t\t\t\t\"currentTextureCoords += deltaTexCoord;\",\n\t\t\t\t\t\t\t\t\"currentLayerHeight -= deltaHeight;\",\n\n\t\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\t\"}\",\n\t\t\t\t\t\t\"return currentTextureCoords;\",\n\n\t\t\t\t\t\"#elif defined( USE_OCLUSION_PARALLAX )\",\n\n\t\t\t\t\t\t\"vec2 prevTCoords = currentTextureCoords + dtex;\",\n\n\t\t\t\t\t\t// Heights for linear interpolation\n\t\t\t\t\t\t\"float nextH = heightFromTexture - currentLayerHeight;\",\n\t\t\t\t\t\t\"float prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;\",\n\n\t\t\t\t\t\t// Proportions for linear interpolation\n\t\t\t\t\t\t\"float weight = nextH / ( nextH - prevH );\",\n\n\t\t\t\t\t\t// Interpolation of texture coordinates\n\t\t\t\t\t\t\"return prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );\",\n\n\t\t\t\t\t\"#else\", // NO_PARALLAX\n\n\t\t\t\t\t\t\"return vUv;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"}\",\n\t\t\t\"#endif\",\n\n\t\t\t\"vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {\",\n\n\t \t\t\t\"vec2 texDx = dFdx( vUv );\",\n\t\t\t\t\"vec2 texDy = dFdy( vUv );\",\n\n\t\t\t\t\"vec3 vSigmaX = dFdx( surfPosition );\",\n\t\t\t\t\"vec3 vSigmaY = dFdy( surfPosition );\",\n\t\t\t\t\"vec3 vR1 = cross( vSigmaY, surfNormal );\",\n\t\t\t\t\"vec3 vR2 = cross( surfNormal, vSigmaX );\",\n\t\t\t\t\"float fDet = dot( vSigmaX, vR1 );\",\n\n\t\t\t\t\"vec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );\",\n\t\t\t\t\"vec3 vProjVtex;\",\n\t\t\t\t\"vProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;\",\n\t\t\t\t\"vProjVtex.z = dot( surfNormal, viewPosition );\",\n\n\t\t\t\t\"return parallaxMap( vProjVtex );\",\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );\",\n\t\t\t\t\"gl_FragColor = texture2D( map, mapUv );\",\n\n\t\t\t\"}\",\n\n\t  ].join( \"\\n\" )\n\n\t};\n\n}\n"]},"metadata":{},"sourceType":"script"}