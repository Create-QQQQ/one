{"ast":null,"code":"module.exports = function (THREE) {\n  /**\n   * Loads a Wavefront .mtl file specifying materials\n   *\n   * @author angelxuanchang\n   */\n  THREE.MTLLoader = function (manager) {\n    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n  };\n\n  THREE.MTLLoader.prototype = {\n    constructor: THREE.MTLLoader,\n    load: function (url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new THREE.XHRLoader(this.manager);\n      loader.setPath(this.path);\n      loader.load(url, function (text) {\n        onLoad(scope.parse(text));\n      }, onProgress, onError);\n    },\n    setPath: function (value) {\n      this.path = value;\n    },\n    setBaseUrl: function (value) {\n      // TODO: Merge with setPath()? Or rename to setTexturePath?\n      this.baseUrl = value;\n    },\n    setCrossOrigin: function (value) {\n      this.crossOrigin = value;\n    },\n    setMaterialOptions: function (value) {\n      this.materialOptions = value;\n    },\n\n    /**\n     * Parses loaded MTL file\n     * @param text - Content of MTL file\n     * @return {THREE.MTLLoader.MaterialCreator}\n     */\n    parse: function (text) {\n      var lines = text.split(\"\\n\");\n      var info = {};\n      var delimiter_pattern = /\\s+/;\n      var materialsInfo = {};\n\n      for (var i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        line = line.trim();\n\n        if (line.length === 0 || line.charAt(0) === '#') {\n          // Blank line or comment ignore\n          continue;\n        }\n\n        var pos = line.indexOf(' ');\n        var key = pos >= 0 ? line.substring(0, pos) : line;\n        key = key.toLowerCase();\n        var value = pos >= 0 ? line.substring(pos + 1) : \"\";\n        value = value.trim();\n\n        if (key === \"newmtl\") {\n          // New material\n          info = {\n            name: value\n          };\n          materialsInfo[value] = info;\n        } else if (info) {\n          if (key === \"ka\" || key === \"kd\" || key === \"ks\") {\n            var ss = value.split(delimiter_pattern, 3);\n            info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];\n          } else {\n            info[key] = value;\n          }\n        }\n      }\n\n      var materialCreator = new THREE.MTLLoader.MaterialCreator(this.baseUrl, this.materialOptions);\n      materialCreator.setCrossOrigin(this.crossOrigin);\n      materialCreator.setManager(this.manager);\n      materialCreator.setMaterials(materialsInfo);\n      return materialCreator;\n    }\n  };\n  /**\n   * Create a new THREE-MTLLoader.MaterialCreator\n   * @param baseUrl - Url relative to which textures are loaded\n   * @param options - Set of options on how to construct the materials\n   *                  side: Which side to apply the material\n   *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide\n   *                  wrap: What type of wrapping to apply for textures\n   *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n   *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n   *                                Default: false, assumed to be already normalized\n   *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n   *                                  Default: false\n   * @constructor\n   */\n\n  THREE.MTLLoader.MaterialCreator = function (baseUrl, options) {\n    this.baseUrl = baseUrl;\n    this.options = options;\n    this.materialsInfo = {};\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n    this.side = this.options && this.options.side ? this.options.side : THREE.FrontSide;\n    this.wrap = this.options && this.options.wrap ? this.options.wrap : THREE.RepeatWrapping;\n  };\n\n  THREE.MTLLoader.MaterialCreator.prototype = {\n    constructor: THREE.MTLLoader.MaterialCreator,\n    setCrossOrigin: function (value) {\n      this.crossOrigin = value;\n    },\n    setManager: function (value) {\n      this.manager = value;\n    },\n    setMaterials: function (materialsInfo) {\n      this.materialsInfo = this.convert(materialsInfo);\n      this.materials = {};\n      this.materialsArray = [];\n      this.nameLookup = {};\n    },\n    convert: function (materialsInfo) {\n      if (!this.options) return materialsInfo;\n      var converted = {};\n\n      for (var mn in materialsInfo) {\n        // Convert materials info into normalized form based on options\n        var mat = materialsInfo[mn];\n        var covmat = {};\n        converted[mn] = covmat;\n\n        for (var prop in mat) {\n          var save = true;\n          var value = mat[prop];\n          var lprop = prop.toLowerCase();\n\n          switch (lprop) {\n            case 'kd':\n            case 'ka':\n            case 'ks':\n              // Diffuse color (color under white light) using RGB values\n              if (this.options && this.options.normalizeRGB) {\n                value = [value[0] / 255, value[1] / 255, value[2] / 255];\n              }\n\n              if (this.options && this.options.ignoreZeroRGBs) {\n                if (value[0] === 0 && value[1] === 0 && value[1] === 0) {\n                  // ignore\n                  save = false;\n                }\n              }\n\n              break;\n\n            default:\n              break;\n          }\n\n          if (save) {\n            covmat[lprop] = value;\n          }\n        }\n      }\n\n      return converted;\n    },\n    preload: function () {\n      for (var mn in this.materialsInfo) {\n        this.create(mn);\n      }\n    },\n    getIndex: function (materialName) {\n      return this.nameLookup[materialName];\n    },\n    getAsArray: function () {\n      var index = 0;\n\n      for (var mn in this.materialsInfo) {\n        this.materialsArray[index] = this.create(mn);\n        this.nameLookup[mn] = index;\n        index++;\n      }\n\n      return this.materialsArray;\n    },\n    create: function (materialName) {\n      if (this.materials[materialName] === undefined) {\n        this.createMaterial_(materialName);\n      }\n\n      return this.materials[materialName];\n    },\n    createMaterial_: function (materialName) {\n      // Create material\n      var mat = this.materialsInfo[materialName];\n      var params = {\n        name: materialName,\n        side: this.side\n      };\n\n      for (var prop in mat) {\n        var value = mat[prop];\n        if (value === '') continue;\n\n        switch (prop.toLowerCase()) {\n          // Ns is material specular exponent\n          case 'kd':\n            // Diffuse color (color under white light) using RGB values\n            params['color'] = new THREE.Color().fromArray(value);\n            break;\n\n          case 'ks':\n            // Specular color (color when light is reflected from shiny surface) using RGB values\n            params['specular'] = new THREE.Color().fromArray(value);\n            break;\n\n          case 'map_kd':\n            // Diffuse texture map\n            params['map'] = this.loadTexture(this.baseUrl + value);\n            params['map'].wrapS = this.wrap;\n            params['map'].wrapT = this.wrap;\n            break;\n\n          case 'ns':\n            // The specular exponent (defines the focus of the specular highlight)\n            // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n            params['shininess'] = parseFloat(value);\n            break;\n\n          case 'd':\n            if (value < 1) {\n              params['opacity'] = value;\n              params['transparent'] = true;\n            }\n\n            break;\n\n          case 'Tr':\n            if (value > 0) {\n              params['opacity'] = 1 - value;\n              params['transparent'] = true;\n            }\n\n            break;\n\n          case 'map_bump':\n          case 'bump':\n            // Bump texture map\n            if (params['bumpMap']) break; // Avoid loading twice.\n\n            params['bumpMap'] = this.loadTexture(this.baseUrl + value);\n            params['bumpMap'].wrapS = this.wrap;\n            params['bumpMap'].wrapT = this.wrap;\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      this.materials[materialName] = new THREE.MeshPhongMaterial(params);\n      return this.materials[materialName];\n    },\n    loadTexture: function (url, mapping, onLoad, onProgress, onError) {\n      var texture;\n      var loader = THREE.Loader.Handlers.get(url);\n      var manager = this.manager !== undefined ? this.manager : THREE.DefaultLoadingManager;\n\n      if (loader === null) {\n        loader = new THREE.TextureLoader(manager);\n      }\n\n      if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);\n      texture = loader.load(url, onLoad, onProgress, onError);\n      if (mapping !== undefined) texture.mapping = mapping;\n      return texture;\n    }\n  };\n  THREE.EventDispatcher.prototype.apply(THREE.MTLLoader.prototype);\n};","map":{"version":3,"sources":["E:/baking/hongpeibang/node_modules/three-js/addons/MTLLoader.js"],"names":["module","exports","THREE","MTLLoader","manager","undefined","DefaultLoadingManager","prototype","constructor","load","url","onLoad","onProgress","onError","scope","loader","XHRLoader","setPath","path","text","parse","value","setBaseUrl","baseUrl","setCrossOrigin","crossOrigin","setMaterialOptions","materialOptions","lines","split","info","delimiter_pattern","materialsInfo","i","length","line","trim","charAt","pos","indexOf","key","substring","toLowerCase","name","ss","parseFloat","materialCreator","MaterialCreator","setManager","setMaterials","options","materials","materialsArray","nameLookup","side","FrontSide","wrap","RepeatWrapping","convert","converted","mn","mat","covmat","prop","save","lprop","normalizeRGB","ignoreZeroRGBs","preload","create","getIndex","materialName","getAsArray","index","createMaterial_","params","Color","fromArray","loadTexture","wrapS","wrapT","MeshPhongMaterial","mapping","texture","Loader","Handlers","get","TextureLoader","EventDispatcher","apply"],"mappings":"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","sourcesContent":["module.exports = function( THREE ){\n\n\t/**\n\t * Loads a Wavefront .mtl file specifying materials\n\t *\n\t * @author angelxuanchang\n\t */\n\n\tTHREE.MTLLoader = function( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\t};\n\n\tTHREE.MTLLoader.prototype = {\n\n\t\tconstructor: THREE.MTLLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\n\t\t},\n\n\t\tsetBaseUrl: function( value ) {\n\n\t\t\t// TODO: Merge with setPath()? Or rename to setTexturePath?\n\n\t\t\tthis.baseUrl = value;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\n\t\t},\n\n\t\tsetMaterialOptions: function ( value ) {\n\n\t\t\tthis.materialOptions = value;\n\n\t\t},\n\n\t\t/**\n\t\t * Parses loaded MTL file\n\t\t * @param text - Content of MTL file\n\t\t * @return {THREE.MTLLoader.MaterialCreator}\n\t\t */\n\t\tparse: function ( text ) {\n\n\t\t\tvar lines = text.split( \"\\n\" );\n\t\t\tvar info = {};\n\t\t\tvar delimiter_pattern = /\\s+/;\n\t\t\tvar materialsInfo = {};\n\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tvar line = lines[ i ];\n\t\t\t\tline = line.trim();\n\n\t\t\t\tif ( line.length === 0 || line.charAt( 0 ) === '#' ) {\n\n\t\t\t\t\t// Blank line or comment ignore\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar pos = line.indexOf( ' ' );\n\n\t\t\t\tvar key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;\n\t\t\t\tkey = key.toLowerCase();\n\n\t\t\t\tvar value = ( pos >= 0 ) ? line.substring( pos + 1 ) : \"\";\n\t\t\t\tvalue = value.trim();\n\n\t\t\t\tif ( key === \"newmtl\" ) {\n\n\t\t\t\t\t// New material\n\n\t\t\t\t\tinfo = { name: value };\n\t\t\t\t\tmaterialsInfo[ value ] = info;\n\n\t\t\t\t} else if ( info ) {\n\n\t\t\t\t\tif ( key === \"ka\" || key === \"kd\" || key === \"ks\" ) {\n\n\t\t\t\t\t\tvar ss = value.split( delimiter_pattern, 3 );\n\t\t\t\t\t\tinfo[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tinfo[ key ] = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar materialCreator = new THREE.MTLLoader.MaterialCreator( this.baseUrl, this.materialOptions );\n\t\t\tmaterialCreator.setCrossOrigin( this.crossOrigin );\n\t\t\tmaterialCreator.setManager( this.manager );\n\t\t\tmaterialCreator.setMaterials( materialsInfo );\n\t\t\treturn materialCreator;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Create a new THREE-MTLLoader.MaterialCreator\n\t * @param baseUrl - Url relative to which textures are loaded\n\t * @param options - Set of options on how to construct the materials\n\t *                  side: Which side to apply the material\n\t *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide\n\t *                  wrap: What type of wrapping to apply for textures\n\t *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n\t *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n\t *                                Default: false, assumed to be already normalized\n\t *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n\t *                                  Default: false\n\t * @constructor\n\t */\n\n\tTHREE.MTLLoader.MaterialCreator = function( baseUrl, options ) {\n\n\t\tthis.baseUrl = baseUrl;\n\t\tthis.options = options;\n\t\tthis.materialsInfo = {};\n\t\tthis.materials = {};\n\t\tthis.materialsArray = [];\n\t\tthis.nameLookup = {};\n\n\t\tthis.side = ( this.options && this.options.side ) ? this.options.side : THREE.FrontSide;\n\t\tthis.wrap = ( this.options && this.options.wrap ) ? this.options.wrap : THREE.RepeatWrapping;\n\n\t};\n\n\tTHREE.MTLLoader.MaterialCreator.prototype = {\n\n\t\tconstructor: THREE.MTLLoader.MaterialCreator,\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\n\t\t},\n\n\t\tsetManager: function ( value ) {\n\n\t\t\tthis.manager = value;\n\n\t\t},\n\n\t\tsetMaterials: function( materialsInfo ) {\n\n\t\t\tthis.materialsInfo = this.convert( materialsInfo );\n\t\t\tthis.materials = {};\n\t\t\tthis.materialsArray = [];\n\t\t\tthis.nameLookup = {};\n\n\t\t},\n\n\t\tconvert: function( materialsInfo ) {\n\n\t\t\tif ( ! this.options ) return materialsInfo;\n\n\t\t\tvar converted = {};\n\n\t\t\tfor ( var mn in materialsInfo ) {\n\n\t\t\t\t// Convert materials info into normalized form based on options\n\n\t\t\t\tvar mat = materialsInfo[ mn ];\n\n\t\t\t\tvar covmat = {};\n\n\t\t\t\tconverted[ mn ] = covmat;\n\n\t\t\t\tfor ( var prop in mat ) {\n\n\t\t\t\t\tvar save = true;\n\t\t\t\t\tvar value = mat[ prop ];\n\t\t\t\t\tvar lprop = prop.toLowerCase();\n\n\t\t\t\t\tswitch ( lprop ) {\n\n\t\t\t\t\t\tcase 'kd':\n\t\t\t\t\t\tcase 'ka':\n\t\t\t\t\t\tcase 'ks':\n\n\t\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\t\t\tif ( this.options && this.options.normalizeRGB ) {\n\n\t\t\t\t\t\t\t\tvalue = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( this.options && this.options.ignoreZeroRGBs ) {\n\n\t\t\t\t\t\t\t\tif ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 1 ] === 0 ) {\n\n\t\t\t\t\t\t\t\t\t// ignore\n\n\t\t\t\t\t\t\t\t\tsave = false;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( save ) {\n\n\t\t\t\t\t\tcovmat[ lprop ] = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn converted;\n\n\t\t},\n\n\t\tpreload: function () {\n\n\t\t\tfor ( var mn in this.materialsInfo ) {\n\n\t\t\t\tthis.create( mn );\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetIndex: function( materialName ) {\n\n\t\t\treturn this.nameLookup[ materialName ];\n\n\t\t},\n\n\t\tgetAsArray: function() {\n\n\t\t\tvar index = 0;\n\n\t\t\tfor ( var mn in this.materialsInfo ) {\n\n\t\t\t\tthis.materialsArray[ index ] = this.create( mn );\n\t\t\t\tthis.nameLookup[ mn ] = index;\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\treturn this.materialsArray;\n\n\t\t},\n\n\t\tcreate: function ( materialName ) {\n\n\t\t\tif ( this.materials[ materialName ] === undefined ) {\n\n\t\t\t\tthis.createMaterial_( materialName );\n\n\t\t\t}\n\n\t\t\treturn this.materials[ materialName ];\n\n\t\t},\n\n\t\tcreateMaterial_: function ( materialName ) {\n\n\t\t\t// Create material\n\n\t\t\tvar mat = this.materialsInfo[ materialName ];\n\t\t\tvar params = {\n\n\t\t\t\tname: materialName,\n\t\t\t\tside: this.side\n\n\t\t\t};\n\n\t\t\tfor ( var prop in mat ) {\n\n\t\t\t\tvar value = mat[ prop ];\n\n\t\t\t\tif ( value === '' ) continue;\n\n\t\t\t\tswitch ( prop.toLowerCase() ) {\n\n\t\t\t\t\t// Ns is material specular exponent\n\n\t\t\t\t\tcase 'kd':\n\n\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\t\tparams[ 'color' ] = new THREE.Color().fromArray( value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ks':\n\n\t\t\t\t\t\t// Specular color (color when light is reflected from shiny surface) using RGB values\n\t\t\t\t\t\tparams[ 'specular' ] = new THREE.Color().fromArray( value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'map_kd':\n\n\t\t\t\t\t\t// Diffuse texture map\n\n\t\t\t\t\t\tparams[ 'map' ] = this.loadTexture( this.baseUrl + value );\n\t\t\t\t\t\tparams[ 'map' ].wrapS = this.wrap;\n\t\t\t\t\t\tparams[ 'map' ].wrapT = this.wrap;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ns':\n\n\t\t\t\t\t\t// The specular exponent (defines the focus of the specular highlight)\n\t\t\t\t\t\t// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n\n\t\t\t\t\t\tparams[ 'shininess' ] = parseFloat( value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'd':\n\n\t\t\t\t\t\tif ( value < 1 ) {\n\n\t\t\t\t\t\t\tparams[ 'opacity' ] = value;\n\t\t\t\t\t\t\tparams[ 'transparent' ] = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Tr':\n\n\t\t\t\t\t\tif ( value > 0 ) {\n\n\t\t\t\t\t\t\tparams[ 'opacity' ] = 1 - value;\n\t\t\t\t\t\t\tparams[ 'transparent' ] = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'map_bump':\n\t\t\t\t\tcase 'bump':\n\n\t\t\t\t\t\t// Bump texture map\n\n\t\t\t\t\t\tif ( params[ 'bumpMap' ] ) break; // Avoid loading twice.\n\n\t\t\t\t\t\tparams[ 'bumpMap' ] = this.loadTexture( this.baseUrl + value );\n\t\t\t\t\t\tparams[ 'bumpMap' ].wrapS = this.wrap;\n\t\t\t\t\t\tparams[ 'bumpMap' ].wrapT = this.wrap;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.materials[ materialName ] = new THREE.MeshPhongMaterial( params );\n\t\t\treturn this.materials[ materialName ];\n\n\t\t},\n\n\n\t\tloadTexture: function ( url, mapping, onLoad, onProgress, onError ) {\n\n\t\t\tvar texture;\n\t\t\tvar loader = THREE.Loader.Handlers.get( url );\n\t\t\tvar manager = ( this.manager !== undefined ) ? this.manager : THREE.DefaultLoadingManager;\n\n\t\t\tif ( loader === null ) {\n\n\t\t\t\tloader = new THREE.TextureLoader( manager );\n\n\t\t\t}\n\n\t\t\tif ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );\n\t\t\ttexture = loader.load( url, onLoad, onProgress, onError );\n\n\t\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t};\n\n\tTHREE.EventDispatcher.prototype.apply( THREE.MTLLoader.prototype );\n\n};"]},"metadata":{},"sourceType":"script"}