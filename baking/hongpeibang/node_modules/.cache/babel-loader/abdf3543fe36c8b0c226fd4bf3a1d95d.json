{"ast":null,"code":"module.exports = function (THREE) {\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author alteredq / http://alteredqualia.com/\n   */\n  THREE.JSONLoader = function (manager) {\n    if (typeof manager === 'boolean') {\n      console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');\n      manager = undefined;\n    }\n\n    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n    this.withCredentials = false;\n  };\n\n  THREE.JSONLoader.prototype = {\n    constructor: THREE.JSONLoader,\n\n    // Deprecated\n    get statusDomElement() {\n      if (this._statusDomElement === undefined) {\n        this._statusDomElement = document.createElement('div');\n      }\n\n      console.warn('THREE.JSONLoader: .statusDomElement has been removed.');\n      return this._statusDomElement;\n    },\n\n    load: function (url, onLoad, onProgress, onError) {\n      var scope = this;\n      var texturePath = this.texturePath && typeof this.texturePath === \"string\" ? this.texturePath : THREE.Loader.prototype.extractUrlBase(url);\n      var loader = new THREE.XHRLoader(this.manager);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (text) {\n        var json = JSON.parse(text);\n        var metadata = json.metadata;\n\n        if (metadata !== undefined) {\n          var type = metadata.type;\n\n          if (type !== undefined) {\n            if (type.toLowerCase() === 'object') {\n              console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.');\n              return;\n            }\n\n            if (type.toLowerCase() === 'scene') {\n              console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.');\n              return;\n            }\n          }\n        }\n\n        var object = scope.parse(json, texturePath);\n        onLoad(object.geometry, object.materials);\n      }, onProgress, onError);\n    },\n    setTexturePath: function (value) {\n      this.texturePath = value;\n    },\n    parse: function (json, texturePath) {\n      var geometry = new THREE.Geometry(),\n          scale = json.scale !== undefined ? 1.0 / json.scale : 1.0;\n      parseModel(scale);\n      parseSkin();\n      parseMorphing(scale);\n      parseAnimations();\n      geometry.computeFaceNormals();\n      geometry.computeBoundingSphere();\n\n      function parseModel(scale) {\n        function isBitSet(value, position) {\n          return value & 1 << position;\n        }\n\n        var i,\n            j,\n            fi,\n            offset,\n            zLength,\n            colorIndex,\n            normalIndex,\n            uvIndex,\n            materialIndex,\n            type,\n            isQuad,\n            hasMaterial,\n            hasFaceVertexUv,\n            hasFaceNormal,\n            hasFaceVertexNormal,\n            hasFaceColor,\n            hasFaceVertexColor,\n            vertex,\n            face,\n            faceA,\n            faceB,\n            hex,\n            normal,\n            uvLayer,\n            uv,\n            u,\n            v,\n            faces = json.faces,\n            vertices = json.vertices,\n            normals = json.normals,\n            colors = json.colors,\n            nUvLayers = 0;\n\n        if (json.uvs !== undefined) {\n          // disregard empty arrays\n          for (i = 0; i < json.uvs.length; i++) {\n            if (json.uvs[i].length) nUvLayers++;\n          }\n\n          for (i = 0; i < nUvLayers; i++) {\n            geometry.faceVertexUvs[i] = [];\n          }\n        }\n\n        offset = 0;\n        zLength = vertices.length;\n\n        while (offset < zLength) {\n          vertex = new THREE.Vector3();\n          vertex.x = vertices[offset++] * scale;\n          vertex.y = vertices[offset++] * scale;\n          vertex.z = vertices[offset++] * scale;\n          geometry.vertices.push(vertex);\n        }\n\n        offset = 0;\n        zLength = faces.length;\n\n        while (offset < zLength) {\n          type = faces[offset++];\n          isQuad = isBitSet(type, 0);\n          hasMaterial = isBitSet(type, 1);\n          hasFaceVertexUv = isBitSet(type, 3);\n          hasFaceNormal = isBitSet(type, 4);\n          hasFaceVertexNormal = isBitSet(type, 5);\n          hasFaceColor = isBitSet(type, 6);\n          hasFaceVertexColor = isBitSet(type, 7); // console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n          if (isQuad) {\n            faceA = new THREE.Face3();\n            faceA.a = faces[offset];\n            faceA.b = faces[offset + 1];\n            faceA.c = faces[offset + 3];\n            faceB = new THREE.Face3();\n            faceB.a = faces[offset + 1];\n            faceB.b = faces[offset + 2];\n            faceB.c = faces[offset + 3];\n            offset += 4;\n\n            if (hasMaterial) {\n              materialIndex = faces[offset++];\n              faceA.materialIndex = materialIndex;\n              faceB.materialIndex = materialIndex;\n            } // to get face <=> uv index correspondence\n\n\n            fi = geometry.faces.length;\n\n            if (hasFaceVertexUv) {\n              for (i = 0; i < nUvLayers; i++) {\n                uvLayer = json.uvs[i];\n                geometry.faceVertexUvs[i][fi] = [];\n                geometry.faceVertexUvs[i][fi + 1] = [];\n\n                for (j = 0; j < 4; j++) {\n                  uvIndex = faces[offset++];\n                  u = uvLayer[uvIndex * 2];\n                  v = uvLayer[uvIndex * 2 + 1];\n                  uv = new THREE.Vector2(u, v);\n                  if (j !== 2) geometry.faceVertexUvs[i][fi].push(uv);\n                  if (j !== 0) geometry.faceVertexUvs[i][fi + 1].push(uv);\n                }\n              }\n            }\n\n            if (hasFaceNormal) {\n              normalIndex = faces[offset++] * 3;\n              faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);\n              faceB.normal.copy(faceA.normal);\n            }\n\n            if (hasFaceVertexNormal) {\n              for (i = 0; i < 4; i++) {\n                normalIndex = faces[offset++] * 3;\n                normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);\n                if (i !== 2) faceA.vertexNormals.push(normal);\n                if (i !== 0) faceB.vertexNormals.push(normal);\n              }\n            }\n\n            if (hasFaceColor) {\n              colorIndex = faces[offset++];\n              hex = colors[colorIndex];\n              faceA.color.setHex(hex);\n              faceB.color.setHex(hex);\n            }\n\n            if (hasFaceVertexColor) {\n              for (i = 0; i < 4; i++) {\n                colorIndex = faces[offset++];\n                hex = colors[colorIndex];\n                if (i !== 2) faceA.vertexColors.push(new THREE.Color(hex));\n                if (i !== 0) faceB.vertexColors.push(new THREE.Color(hex));\n              }\n            }\n\n            geometry.faces.push(faceA);\n            geometry.faces.push(faceB);\n          } else {\n            face = new THREE.Face3();\n            face.a = faces[offset++];\n            face.b = faces[offset++];\n            face.c = faces[offset++];\n\n            if (hasMaterial) {\n              materialIndex = faces[offset++];\n              face.materialIndex = materialIndex;\n            } // to get face <=> uv index correspondence\n\n\n            fi = geometry.faces.length;\n\n            if (hasFaceVertexUv) {\n              for (i = 0; i < nUvLayers; i++) {\n                uvLayer = json.uvs[i];\n                geometry.faceVertexUvs[i][fi] = [];\n\n                for (j = 0; j < 3; j++) {\n                  uvIndex = faces[offset++];\n                  u = uvLayer[uvIndex * 2];\n                  v = uvLayer[uvIndex * 2 + 1];\n                  uv = new THREE.Vector2(u, v);\n                  geometry.faceVertexUvs[i][fi].push(uv);\n                }\n              }\n            }\n\n            if (hasFaceNormal) {\n              normalIndex = faces[offset++] * 3;\n              face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);\n            }\n\n            if (hasFaceVertexNormal) {\n              for (i = 0; i < 3; i++) {\n                normalIndex = faces[offset++] * 3;\n                normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);\n                face.vertexNormals.push(normal);\n              }\n            }\n\n            if (hasFaceColor) {\n              colorIndex = faces[offset++];\n              face.color.setHex(colors[colorIndex]);\n            }\n\n            if (hasFaceVertexColor) {\n              for (i = 0; i < 3; i++) {\n                colorIndex = faces[offset++];\n                face.vertexColors.push(new THREE.Color(colors[colorIndex]));\n              }\n            }\n\n            geometry.faces.push(face);\n          }\n        }\n      }\n\n      ;\n\n      function parseSkin() {\n        var influencesPerVertex = json.influencesPerVertex !== undefined ? json.influencesPerVertex : 2;\n\n        if (json.skinWeights) {\n          for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {\n            var x = json.skinWeights[i];\n            var y = influencesPerVertex > 1 ? json.skinWeights[i + 1] : 0;\n            var z = influencesPerVertex > 2 ? json.skinWeights[i + 2] : 0;\n            var w = influencesPerVertex > 3 ? json.skinWeights[i + 3] : 0;\n            geometry.skinWeights.push(new THREE.Vector4(x, y, z, w));\n          }\n        }\n\n        if (json.skinIndices) {\n          for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {\n            var a = json.skinIndices[i];\n            var b = influencesPerVertex > 1 ? json.skinIndices[i + 1] : 0;\n            var c = influencesPerVertex > 2 ? json.skinIndices[i + 2] : 0;\n            var d = influencesPerVertex > 3 ? json.skinIndices[i + 3] : 0;\n            geometry.skinIndices.push(new THREE.Vector4(a, b, c, d));\n          }\n        }\n\n        geometry.bones = json.bones;\n\n        if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {\n          console.warn('When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' + geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.');\n        }\n      }\n\n      ;\n\n      function parseMorphing(scale) {\n        if (json.morphTargets !== undefined) {\n          for (var i = 0, l = json.morphTargets.length; i < l; i++) {\n            geometry.morphTargets[i] = {};\n            geometry.morphTargets[i].name = json.morphTargets[i].name;\n            geometry.morphTargets[i].vertices = [];\n            var dstVertices = geometry.morphTargets[i].vertices;\n            var srcVertices = json.morphTargets[i].vertices;\n\n            for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {\n              var vertex = new THREE.Vector3();\n              vertex.x = srcVertices[v] * scale;\n              vertex.y = srcVertices[v + 1] * scale;\n              vertex.z = srcVertices[v + 2] * scale;\n              dstVertices.push(vertex);\n            }\n          }\n        }\n\n        if (json.morphColors !== undefined && json.morphColors.length > 0) {\n          console.warn('THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.');\n          var faces = geometry.faces;\n          var morphColors = json.morphColors[0].colors;\n\n          for (var i = 0, l = faces.length; i < l; i++) {\n            faces[i].color.fromArray(morphColors, i * 3);\n          }\n        }\n      }\n\n      function parseAnimations() {\n        var outputAnimations = []; // parse old style Bone/Hierarchy animations\n\n        var animations = [];\n\n        if (json.animation !== undefined) {\n          animations.push(json.animation);\n        }\n\n        if (json.animations !== undefined) {\n          if (json.animations.length) {\n            animations = animations.concat(json.animations);\n          } else {\n            animations.push(json.animations);\n          }\n        }\n\n        for (var i = 0; i < animations.length; i++) {\n          var clip = THREE.AnimationClip.parseAnimation(animations[i], geometry.bones);\n          if (clip) outputAnimations.push(clip);\n        } // parse implicit morph animations\n\n\n        if (geometry.morphTargets) {\n          // TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n          var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);\n          outputAnimations = outputAnimations.concat(morphAnimationClips);\n        }\n\n        if (outputAnimations.length > 0) geometry.animations = outputAnimations;\n      }\n\n      ;\n\n      if (json.materials === undefined || json.materials.length === 0) {\n        return {\n          geometry: geometry\n        };\n      } else {\n        var materials = THREE.Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);\n        return {\n          geometry: geometry,\n          materials: materials\n        };\n      }\n    }\n  };\n};","map":{"version":3,"sources":["E:/baking/hongpeibang/node_modules/three-js/addons/JSONLoader.js"],"names":["module","exports","THREE","JSONLoader","manager","console","warn","undefined","DefaultLoadingManager","withCredentials","prototype","constructor","statusDomElement","_statusDomElement","document","createElement","load","url","onLoad","onProgress","onError","scope","texturePath","Loader","extractUrlBase","loader","XHRLoader","setWithCredentials","text","json","JSON","parse","metadata","type","toLowerCase","error","object","geometry","materials","setTexturePath","value","Geometry","scale","parseModel","parseSkin","parseMorphing","parseAnimations","computeFaceNormals","computeBoundingSphere","isBitSet","position","i","j","fi","offset","zLength","colorIndex","normalIndex","uvIndex","materialIndex","isQuad","hasMaterial","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","hasFaceVertexColor","vertex","face","faceA","faceB","hex","normal","uvLayer","uv","u","v","faces","vertices","normals","colors","nUvLayers","uvs","length","faceVertexUvs","Vector3","x","y","z","push","Face3","a","b","c","Vector2","set","copy","vertexNormals","color","setHex","vertexColors","Color","influencesPerVertex","skinWeights","l","w","Vector4","skinIndices","d","bones","morphTargets","name","dstVertices","srcVertices","vl","morphColors","fromArray","outputAnimations","animations","animation","concat","clip","AnimationClip","parseAnimation","morphAnimationClips","CreateClipsFromMorphTargetSequences","initMaterials","crossOrigin"],"mappings":"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","sourcesContent":["module.exports = function( THREE ){\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tTHREE.JSONLoader = function ( manager ) {\n\n\t\tif ( typeof manager === 'boolean' ) {\n\n\t\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\t\tmanager = undefined;\n\n\t\t}\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\t\tthis.withCredentials = false;\n\n\t};\n\n\tTHREE.JSONLoader.prototype = {\n\n\t\tconstructor: THREE.JSONLoader,\n\n\t\t// Deprecated\n\n\t\tget statusDomElement () {\n\n\t\t\tif ( this._statusDomElement === undefined ) {\n\n\t\t\t\tthis._statusDomElement = document.createElement( 'div' );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );\n\t\t\treturn this._statusDomElement;\n\n\t\t},\n\n\t\tload: function( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );\n\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tvar json = JSON.parse( text );\n\t\t\t\tvar metadata = json.metadata;\n\n\t\t\t\tif ( metadata !== undefined ) {\n\n\t\t\t\t\tvar type = metadata.type;\n\n\t\t\t\t\tif ( type !== undefined ) {\n\n\t\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar object = scope.parse( json, texturePath );\n\t\t\t\tonLoad( object.geometry, object.materials );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetTexturePath: function ( value ) {\n\n\t\t\tthis.texturePath = value;\n\n\t\t},\n\n\t\tparse: function ( json, texturePath ) {\n\n\t\t\tvar geometry = new THREE.Geometry(),\n\t\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\n\t\t\tparseModel( scale );\n\n\t\t\tparseSkin();\n\t\t\tparseMorphing( scale );\n\t\t\tparseAnimations();\n\n\t\t\tgeometry.computeFaceNormals();\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\tfunction parseModel( scale ) {\n\n\t\t\t\tfunction isBitSet( value, position ) {\n\n\t\t\t\t\treturn value & ( 1 << position );\n\n\t\t\t\t}\n\n\t\t\t\tvar i, j, fi,\n\n\t\t\t\toffset, zLength,\n\n\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\n\t\t\t\ttype,\n\t\t\t\tisQuad,\n\t\t\t\thasMaterial,\n\t\t\t\thasFaceVertexUv,\n\t\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\t\thasFaceColor, hasFaceVertexColor,\n\n\t\t\tvertex, face, faceA, faceB, hex, normal,\n\n\t\t\t\tuvLayer, uv, u, v,\n\n\t\t\t\tfaces = json.faces,\n\t\t\t\tvertices = json.vertices,\n\t\t\t\tnormals = json.normals,\n\t\t\t\tcolors = json.colors,\n\n\t\t\t\tnUvLayers = 0;\n\n\t\t\t\tif ( json.uvs !== undefined ) {\n\n\t\t\t\t\t// disregard empty arrays\n\n\t\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\n\t\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = vertices.length;\n\n\t\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\t\tvertex = new THREE.Vector3();\n\n\t\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\n\t\t\t\t\tgeometry.vertices.push( vertex );\n\n\t\t\t\t}\n\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = faces.length;\n\n\t\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\t\ttype = faces[ offset ++ ];\n\n\n\t\t\t\t\tisQuad              = isBitSet( type, 0 );\n\t\t\t\t\thasMaterial         = isBitSet( type, 1 );\n\t\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\t\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\t\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\n\t\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\n\t\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n\t\t\t\t\tif ( isQuad ) {\n\n\t\t\t\t\t\tfaceA = new THREE.Face3();\n\t\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\n\t\t\t\t\t\tfaceB = new THREE.Face3();\n\t\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\n\t\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\n\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\t\tfaceB.color.setHex( hex );\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\t\tgeometry.faces.push( faceB );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tface = new THREE.Face3();\n\t\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\t\tface.c = faces[ offset ++ ];\n\n\t\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.faces.push( face );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tfunction parseSkin() {\n\n\t\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\n\t\t\t\tif ( json.skinWeights ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\t\tvar x =                               json.skinWeights[ i ];\n\t\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\n\t\t\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.skinIndices ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\t\tvar a =                               json.skinIndices[ i ];\n\t\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\n\t\t\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.bones = json.bones;\n\n\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\n\t\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tfunction parseMorphing( scale ) {\n\n\t\t\t\tif ( json.morphTargets !== undefined ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\n\t\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\n\t\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\n\t\t\t\t\t\t\tvar vertex = new THREE.Vector3();\n\t\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\n\t\t\t\t\t\t\tdstVertices.push( vertex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseAnimations() {\n\n\t\t\t\tvar outputAnimations = [];\n\n\t\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\t\tvar animations = [];\n\n\t\t\t\tif ( json.animation !== undefined ) {\n\n\t\t\t\t\tanimations.push( json.animation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.animations !== undefined ) {\n\n\t\t\t\t\tif ( json.animations.length ) {\n\n\t\t\t\t\t\tanimations = animations.concat( json.animations );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tanimations.push( json.animations );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\n\t\t\t\t\tvar clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\n\t\t\t\t}\n\n\t\t\t\t// parse implicit morph animations\n\t\t\t\tif ( geometry.morphTargets ) {\n\n\t\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\t\tvar morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\n\t\t\t\t}\n\n\t\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\n\t\t\t};\n\n\t\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\n\t\t\t\treturn { geometry: geometry };\n\n\t\t\t} else {\n\n\t\t\t\tvar materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\n\t\t\t\treturn { geometry: geometry, materials: materials };\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n};"]},"metadata":{},"sourceType":"script"}