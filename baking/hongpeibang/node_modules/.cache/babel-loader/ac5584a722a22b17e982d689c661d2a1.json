{"ast":null,"code":"module.exports = function (THREE) {\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   *\n   * Film grain & scanlines shader\n   *\n   * - ported from HLSL to WebGL / GLSL\n   * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\n   *\n   * Screen Space Static Postprocessor\n   *\n   * Produces an analogue noise overlay similar to a film grain / TV static\n   *\n   * Original implementation and noise algorithm\n   * Pat 'Hawthorne' Shearon\n   *\n   * Optimized scanlines + noise version with intensity scaling\n   * Georg 'Leviathan' Steinrohder\n   *\n   * This version is provided under a Creative Commons Attribution 3.0 License\n   * http://creativecommons.org/licenses/by/3.0/\n   */\n  THREE.FilmShader = {\n    uniforms: {\n      \"tDiffuse\": {\n        type: \"t\",\n        value: null\n      },\n      \"time\": {\n        type: \"f\",\n        value: 0.0\n      },\n      \"nIntensity\": {\n        type: \"f\",\n        value: 0.5\n      },\n      \"sIntensity\": {\n        type: \"f\",\n        value: 0.05\n      },\n      \"sCount\": {\n        type: \"f\",\n        value: 4096\n      },\n      \"grayscale\": {\n        type: \"i\",\n        value: 1\n      }\n    },\n    vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n    fragmentShader: [// control parameter\n    \"uniform float time;\", \"uniform bool grayscale;\", // noise effect intensity value (0 = no effect, 1 = full effect)\n    \"uniform float nIntensity;\", // scanlines effect intensity value (0 = no effect, 1 = full effect)\n    \"uniform float sIntensity;\", // scanlines effect count value (0 = no effect, 4096 = full effect)\n    \"uniform float sCount;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", // sample the source\n    \"vec4 cTextureScreen = texture2D( tDiffuse, vUv );\", // make some noise\n    \"float x = vUv.x * vUv.y * time *  1000.0;\", \"x = mod( x, 13.0 ) * mod( x, 123.0 );\", \"float dx = mod( x, 0.01 );\", // add noise\n    \"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx * 100.0, 0.0, 1.0 );\", // get us a sine and cosine\n    \"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\", // add scanlines\n    \"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\", // interpolate between source and result by intensity\n    \"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\", // convert to grayscale if desired\n    \"if( grayscale ) {\", \"cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\", \"}\", \"gl_FragColor =  vec4( cResult, cTextureScreen.a );\", \"}\"].join(\"\\n\")\n  };\n};","map":{"version":3,"sources":["E:/baking/hongpeibang/node_modules/three-js/addons/FilmShader.js"],"names":["module","exports","THREE","FilmShader","uniforms","type","value","vertexShader","join","fragmentShader"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiB,UAAUC,KAAV,EAAiB;AACjC;;;;;;;;;;;;;;;;;;;;;AAsBAA,EAAAA,KAAK,CAACC,UAAN,GAAmB;AAElBC,IAAAA,QAAQ,EAAE;AAET,kBAAc;AAAEC,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAFL;AAGT,cAAc;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAHL;AAIT,oBAAc;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAJL;AAKT,oBAAc;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OALL;AAMT,gBAAc;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OANL;AAOT,mBAAc;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB;AAPL,KAFQ;AAalBC,IAAAA,YAAY,EAAE,CAEb,mBAFa,EAIb,eAJa,EAMZ,WANY,EAOZ,2EAPY,EASb,GATa,EAWZC,IAXY,CAWN,IAXM,CAbI;AA0BlBC,IAAAA,cAAc,EAAE,CAEf;AACA,yBAHe,EAKf,yBALe,EAOf;AACA,+BARe,EAUf;AACA,+BAXe,EAaf;AACA,2BAde,EAgBf,6BAhBe,EAkBf,mBAlBe,EAoBf,eApBe,EAsBd;AACA,uDAvBc,EAyBd;AACA,+CA1Bc,EA2Bd,uCA3Bc,EA4Bd,4BA5Bc,EA8Bd;AACA,mGA/Bc,EAiCd;AACA,qEAlCc,EAoCd;AACA,4EArCc,EAuCd;AACA,qGAxCc,EA0Cd;AACA,uBA3Cc,EA6Cb,0EA7Ca,EA+Cd,GA/Cc,EAiDd,oDAjDc,EAmDf,GAnDe,EAqDdD,IArDc,CAqDR,IArDQ;AA1BE,GAAnB;AAmFA,CA1GD","sourcesContent":["module.exports = function( THREE ){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Film grain & scanlines shader\n\t *\n\t * - ported from HLSL to WebGL / GLSL\n\t * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\n\t *\n\t * Screen Space Static Postprocessor\n\t *\n\t * Produces an analogue noise overlay similar to a film grain / TV static\n\t *\n\t * Original implementation and noise algorithm\n\t * Pat 'Hawthorne' Shearon\n\t *\n\t * Optimized scanlines + noise version with intensity scaling\n\t * Georg 'Leviathan' Steinrohder\n\t *\n\t * This version is provided under a Creative Commons Attribution 3.0 License\n\t * http://creativecommons.org/licenses/by/3.0/\n\t */\n\n\tTHREE.FilmShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\":   { type: \"t\", value: null },\n\t\t\t\"time\":       { type: \"f\", value: 0.0 },\n\t\t\t\"nIntensity\": { type: \"f\", value: 0.5 },\n\t\t\t\"sIntensity\": { type: \"f\", value: 0.05 },\n\t\t\t\"sCount\":     { type: \"f\", value: 4096 },\n\t\t\t\"grayscale\":  { type: \"i\", value: 1 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vUv = uv;\",\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t// control parameter\n\t\t\t\"uniform float time;\",\n\n\t\t\t\"uniform bool grayscale;\",\n\n\t\t\t// noise effect intensity value (0 = no effect, 1 = full effect)\n\t\t\t\"uniform float nIntensity;\",\n\n\t\t\t// scanlines effect intensity value (0 = no effect, 1 = full effect)\n\t\t\t\"uniform float sIntensity;\",\n\n\t\t\t// scanlines effect count value (0 = no effect, 4096 = full effect)\n\t\t\t\"uniform float sCount;\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t// sample the source\n\t\t\t\t\"vec4 cTextureScreen = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\t// make some noise\n\t\t\t\t\"float x = vUv.x * vUv.y * time *  1000.0;\",\n\t\t\t\t\"x = mod( x, 13.0 ) * mod( x, 123.0 );\",\n\t\t\t\t\"float dx = mod( x, 0.01 );\",\n\n\t\t\t\t// add noise\n\t\t\t\t\"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx * 100.0, 0.0, 1.0 );\",\n\n\t\t\t\t// get us a sine and cosine\n\t\t\t\t\"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\",\n\n\t\t\t\t// add scanlines\n\t\t\t\t\"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\",\n\n\t\t\t\t// interpolate between source and result by intensity\n\t\t\t\t\"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\",\n\n\t\t\t\t// convert to grayscale if desired\n\t\t\t\t\"if( grayscale ) {\",\n\n\t\t\t\t\t\"cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"gl_FragColor =  vec4( cResult, cTextureScreen.a );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\n}\n"]},"metadata":{},"sourceType":"script"}