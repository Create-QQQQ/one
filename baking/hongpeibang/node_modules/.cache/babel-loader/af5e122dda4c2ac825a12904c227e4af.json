{"ast":null,"code":"module.exports = function (THREE) {\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   */\n  THREE.DotScreenPass = function (center, angle, scale) {\n    if (THREE.DotScreenShader === undefined) console.error(\"THREE.DotScreenPass relies on THREE.DotScreenShader\");\n    var shader = THREE.DotScreenShader;\n    this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n    if (center !== undefined) this.uniforms[\"center\"].value.copy(center);\n    if (angle !== undefined) this.uniforms[\"angle\"].value = angle;\n    if (scale !== undefined) this.uniforms[\"scale\"].value = scale;\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader\n    });\n    this.enabled = true;\n    this.renderToScreen = false;\n    this.needsSwap = true;\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    this.scene = new THREE.Scene();\n    this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n    this.scene.add(this.quad);\n  };\n\n  THREE.DotScreenPass.prototype = {\n    render: function (renderer, writeBuffer, readBuffer, delta) {\n      this.uniforms[\"tDiffuse\"].value = readBuffer;\n      this.uniforms[\"tSize\"].value.set(readBuffer.width, readBuffer.height);\n      this.quad.material = this.material;\n\n      if (this.renderToScreen) {\n        renderer.render(this.scene, this.camera);\n      } else {\n        renderer.render(this.scene, this.camera, writeBuffer, false);\n      }\n    }\n  };\n};","map":{"version":3,"sources":["E:/baking/hongpeibang/node_modules/three-js/addons/DotScreenPass.js"],"names":["module","exports","THREE","DotScreenPass","center","angle","scale","DotScreenShader","undefined","console","error","shader","uniforms","UniformsUtils","clone","value","copy","material","ShaderMaterial","vertexShader","fragmentShader","enabled","renderToScreen","needsSwap","camera","OrthographicCamera","scene","Scene","quad","Mesh","PlaneBufferGeometry","add","prototype","render","renderer","writeBuffer","readBuffer","delta","set","width","height"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiB,UAAUC,KAAV,EAAiB;AAEjC;;;AAIAA,EAAAA,KAAK,CAACC,aAAN,GAAsB,UAAWC,MAAX,EAAmBC,KAAnB,EAA0BC,KAA1B,EAAkC;AAEvD,QAAKJ,KAAK,CAACK,eAAN,KAA0BC,SAA/B,EACCC,OAAO,CAACC,KAAR,CAAe,qDAAf;AAED,QAAIC,MAAM,GAAGT,KAAK,CAACK,eAAnB;AAEA,SAAKK,QAAL,GAAgBV,KAAK,CAACW,aAAN,CAAoBC,KAApB,CAA2BH,MAAM,CAACC,QAAlC,CAAhB;AAEA,QAAKR,MAAM,KAAKI,SAAhB,EAA4B,KAAKI,QAAL,CAAe,QAAf,EAA0BG,KAA1B,CAAgCC,IAAhC,CAAsCZ,MAAtC;AAC5B,QAAKC,KAAK,KAAKG,SAAf,EAA2B,KAAKI,QAAL,CAAe,OAAf,EAAyBG,KAAzB,GAAiCV,KAAjC;AAC3B,QAAKC,KAAK,KAAKE,SAAf,EAA2B,KAAKI,QAAL,CAAe,OAAf,EAAyBG,KAAzB,GAAiCT,KAAjC;AAE3B,SAAKW,QAAL,GAAgB,IAAIf,KAAK,CAACgB,cAAV,CAA0B;AAEzCN,MAAAA,QAAQ,EAAE,KAAKA,QAF0B;AAGzCO,MAAAA,YAAY,EAAER,MAAM,CAACQ,YAHoB;AAIzCC,MAAAA,cAAc,EAAET,MAAM,CAACS;AAJkB,KAA1B,CAAhB;AAQA,SAAKC,OAAL,GAAe,IAAf;AACA,SAAKC,cAAL,GAAsB,KAAtB;AACA,SAAKC,SAAL,GAAiB,IAAjB;AAGA,SAAKC,MAAL,GAAc,IAAItB,KAAK,CAACuB,kBAAV,CAA8B,CAAE,CAAhC,EAAmC,CAAnC,EAAsC,CAAtC,EAAyC,CAAE,CAA3C,EAA8C,CAA9C,EAAiD,CAAjD,CAAd;AACA,SAAKC,KAAL,GAAc,IAAIxB,KAAK,CAACyB,KAAV,EAAd;AAEA,SAAKC,IAAL,GAAY,IAAI1B,KAAK,CAAC2B,IAAV,CAAgB,IAAI3B,KAAK,CAAC4B,mBAAV,CAA+B,CAA/B,EAAkC,CAAlC,CAAhB,EAAuD,IAAvD,CAAZ;AACA,SAAKJ,KAAL,CAAWK,GAAX,CAAgB,KAAKH,IAArB;AAEA,GAhCD;;AAkCA1B,EAAAA,KAAK,CAACC,aAAN,CAAoB6B,SAApB,GAAgC;AAE/BC,IAAAA,MAAM,EAAE,UAAWC,QAAX,EAAqBC,WAArB,EAAkCC,UAAlC,EAA8CC,KAA9C,EAAsD;AAE7D,WAAKzB,QAAL,CAAe,UAAf,EAA4BG,KAA5B,GAAoCqB,UAApC;AACA,WAAKxB,QAAL,CAAe,OAAf,EAAyBG,KAAzB,CAA+BuB,GAA/B,CAAoCF,UAAU,CAACG,KAA/C,EAAsDH,UAAU,CAACI,MAAjE;AAEA,WAAKZ,IAAL,CAAUX,QAAV,GAAqB,KAAKA,QAA1B;;AAEA,UAAK,KAAKK,cAAV,EAA2B;AAE1BY,QAAAA,QAAQ,CAACD,MAAT,CAAiB,KAAKP,KAAtB,EAA6B,KAAKF,MAAlC;AAEA,OAJD,MAIO;AAENU,QAAAA,QAAQ,CAACD,MAAT,CAAiB,KAAKP,KAAtB,EAA6B,KAAKF,MAAlC,EAA0CW,WAA1C,EAAuD,KAAvD;AAEA;AAED;AAnB8B,GAAhC;AAuBA,CA/DD","sourcesContent":["module.exports = function( THREE ){\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tTHREE.DotScreenPass = function ( center, angle, scale ) {\n\n\t\tif ( THREE.DotScreenShader === undefined )\n\t\t\tconsole.error( \"THREE.DotScreenPass relies on THREE.DotScreenShader\" );\n\n\t\tvar shader = THREE.DotScreenShader;\n\n\t\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\t\tif ( center !== undefined ) this.uniforms[ \"center\" ].value.copy( center );\n\t\tif ( angle !== undefined ) this.uniforms[ \"angle\" ].value = angle;\n\t\tif ( scale !== undefined ) this.uniforms[ \"scale\" ].value = scale;\n\n\t\tthis.material = new THREE.ShaderMaterial( {\n\n\t\t\tuniforms: this.uniforms,\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t} );\n\n\t\tthis.enabled = true;\n\t\tthis.renderToScreen = false;\n\t\tthis.needsSwap = true;\n\n\n\t\tthis.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\t\tthis.scene  = new THREE.Scene();\n\n\t\tthis.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );\n\t\tthis.scene.add( this.quad );\n\n\t};\n\n\tTHREE.DotScreenPass.prototype = {\n\n\t\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\n\n\t\t\tthis.uniforms[ \"tDiffuse\" ].value = readBuffer;\n\t\t\tthis.uniforms[ \"tSize\" ].value.set( readBuffer.width, readBuffer.height );\n\n\t\t\tthis.quad.material = this.material;\n\n\t\t\tif ( this.renderToScreen ) {\n\n\t\t\t\trenderer.render( this.scene, this.camera );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( this.scene, this.camera, writeBuffer, false );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n};\n"]},"metadata":{},"sourceType":"script"}