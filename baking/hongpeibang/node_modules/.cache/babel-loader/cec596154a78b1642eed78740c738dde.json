{"ast":null,"code":"module.exports = function (THREE) {\n  /**\n   * @author zz85 / https://github.com/zz85 | twitter.com/blurspline\n   *\n   * Depth-of-field shader with bokeh\n   * ported from GLSL shader by Martins Upitis\n   * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\n   *\n   * Requires #define RINGS and SAMPLES integers\n   */\n  THREE.BokehShader = {\n    uniforms: {\n      \"textureWidth\": {\n        type: \"f\",\n        value: 1.0\n      },\n      \"textureHeight\": {\n        type: \"f\",\n        value: 1.0\n      },\n      \"focalDepth\": {\n        type: \"f\",\n        value: 1.0\n      },\n      \"focalLength\": {\n        type: \"f\",\n        value: 24.0\n      },\n      \"fstop\": {\n        type: \"f\",\n        value: 0.9\n      },\n      \"tColor\": {\n        type: \"t\",\n        value: null\n      },\n      \"tDepth\": {\n        type: \"t\",\n        value: null\n      },\n      \"maxblur\": {\n        type: \"f\",\n        value: 1.0\n      },\n      \"showFocus\": {\n        type: \"i\",\n        value: 0\n      },\n      \"manualdof\": {\n        type: \"i\",\n        value: 0\n      },\n      \"vignetting\": {\n        type: \"i\",\n        value: 0\n      },\n      \"depthblur\": {\n        type: \"i\",\n        value: 0\n      },\n      \"threshold\": {\n        type: \"f\",\n        value: 0.5\n      },\n      \"gain\": {\n        type: \"f\",\n        value: 2.0\n      },\n      \"bias\": {\n        type: \"f\",\n        value: 0.5\n      },\n      \"fringe\": {\n        type: \"f\",\n        value: 0.7\n      },\n      \"znear\": {\n        type: \"f\",\n        value: 0.1\n      },\n      \"zfar\": {\n        type: \"f\",\n        value: 100\n      },\n      \"noise\": {\n        type: \"i\",\n        value: 1\n      },\n      \"dithering\": {\n        type: \"f\",\n        value: 0.0001\n      },\n      \"pentagon\": {\n        type: \"i\",\n        value: 0\n      },\n      \"shaderFocus\": {\n        type: \"i\",\n        value: 1\n      },\n      \"focusCoords\": {\n        type: \"v2\",\n        value: new THREE.Vector2()\n      }\n    },\n    vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n    fragmentShader: [\"varying vec2 vUv;\", \"uniform sampler2D tColor;\", \"uniform sampler2D tDepth;\", \"uniform float textureWidth;\", \"uniform float textureHeight;\", \"const float PI = 3.14159265;\", \"uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\", \"uniform float focalLength; //focal length in mm\", \"uniform float fstop; //f-stop value\", \"uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\", \"/*\", \"make sure that these two values are the same for your camera, otherwise distances will be wrong.\", \"*/\", \"uniform float znear; // camera clipping start\", \"uniform float zfar; // camera clipping end\", \"//------------------------------------------\", \"//user variables\", \"const int samples = SAMPLES; //samples on the first ring\", \"const int rings = RINGS; //ring count\", \"const int maxringsamples = rings * samples;\", \"uniform bool manualdof; // manual dof calculation\", \"float ndofstart = 1.0; // near dof blur start\", \"float ndofdist = 2.0; // near dof blur falloff distance\", \"float fdofstart = 1.0; // far dof blur start\", \"float fdofdist = 3.0; // far dof blur falloff distance\", \"float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\", \"uniform bool vignetting; // use optical lens vignetting\", \"float vignout = 1.3; // vignetting outer border\", \"float vignin = 0.0; // vignetting inner border\", \"float vignfade = 22.0; // f-stops till vignete fades\", \"uniform bool shaderFocus;\", \"// disable if you use external focalDepth value\", \"uniform vec2 focusCoords;\", \"// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\", \"// if center of screen use vec2(0.5, 0.5);\", \"uniform float maxblur;\", \"//clamp value of max blur (0.0 = no blur, 1.0 default)\", \"uniform float threshold; // highlight threshold;\", \"uniform float gain; // highlight gain;\", \"uniform float bias; // bokeh edge bias\", \"uniform float fringe; // bokeh chromatic aberration / fringing\", \"uniform bool noise; //use noise instead of pattern for sample dithering\", \"uniform float dithering;\", \"uniform bool depthblur; // blur the depth buffer\", \"float dbsize = 1.25; // depth blur size\", \"/*\", \"next part is experimental\", \"not looking good with small sample and ring count\", \"looks okay starting from samples = 4, rings = 4\", \"*/\", \"uniform bool pentagon; //use pentagon as bokeh shape?\", \"float feather = 0.4; //pentagon shape feather\", \"//------------------------------------------\", \"float penta(vec2 coords) {\", \"//pentagonal shape\", \"float scale = float(rings) - 1.3;\", \"vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\", \"vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\", \"vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\", \"vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\", \"vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\", \"vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\", \"vec4  one = vec4( 1.0 );\", \"vec4 P = vec4((coords),vec2(scale, scale));\", \"vec4 dist = vec4(0.0);\", \"float inorout = -4.0;\", \"dist.x = dot( P, HS0 );\", \"dist.y = dot( P, HS1 );\", \"dist.z = dot( P, HS2 );\", \"dist.w = dot( P, HS3 );\", \"dist = smoothstep( -feather, feather, dist );\", \"inorout += dot( dist, one );\", \"dist.x = dot( P, HS4 );\", \"dist.y = HS5.w - abs( P.z );\", \"dist = smoothstep( -feather, feather, dist );\", \"inorout += dist.x;\", \"return clamp( inorout, 0.0, 1.0 );\", \"}\", \"float bdepth(vec2 coords) {\", \"// Depth buffer blur\", \"float d = 0.0;\", \"float kernel[9];\", \"vec2 offset[9];\", \"vec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;\", \"offset[0] = vec2(-wh.x,-wh.y);\", \"offset[1] = vec2( 0.0, -wh.y);\", \"offset[2] = vec2( wh.x -wh.y);\", \"offset[3] = vec2(-wh.x,  0.0);\", \"offset[4] = vec2( 0.0,   0.0);\", \"offset[5] = vec2( wh.x,  0.0);\", \"offset[6] = vec2(-wh.x, wh.y);\", \"offset[7] = vec2( 0.0,  wh.y);\", \"offset[8] = vec2( wh.x, wh.y);\", \"kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\", \"kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\", \"kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\", \"for( int i=0; i<9; i++ ) {\", \"float tmp = texture2D(tDepth, coords + offset[i]).r;\", \"d += tmp * kernel[i];\", \"}\", \"return d;\", \"}\", \"vec3 color(vec2 coords,float blur) {\", \"//processing the sample\", \"vec3 col = vec3(0.0);\", \"vec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);\", \"col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\", \"col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\", \"col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\", \"vec3 lumcoeff = vec3(0.299,0.587,0.114);\", \"float lum = dot(col.rgb, lumcoeff);\", \"float thresh = max((lum-threshold)*gain, 0.0);\", \"return col+mix(vec3(0.0),col,thresh*blur);\", \"}\", \"vec2 rand(vec2 coord) {\", \"// generating noise / pattern texture for dithering\", \"float noiseX = ((fract(1.0-coord.s*(textureWidth/2.0))*0.25)+(fract(coord.t*(textureHeight/2.0))*0.75))*2.0-1.0;\", \"float noiseY = ((fract(1.0-coord.s*(textureWidth/2.0))*0.75)+(fract(coord.t*(textureHeight/2.0))*0.25))*2.0-1.0;\", \"if (noise) {\", \"noiseX = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;\", \"noiseY = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;\", \"}\", \"return vec2(noiseX,noiseY);\", \"}\", \"vec3 debugFocus(vec3 col, float blur, float depth) {\", \"float edge = 0.002*depth; //distance based edge smoothing\", \"float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\", \"float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\", \"col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\", \"col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\", \"return col;\", \"}\", \"float linearize(float depth) {\", \"return -zfar * znear / (depth * (zfar - znear) - zfar);\", \"}\", \"float vignette() {\", \"float dist = distance(vUv.xy, vec2(0.5,0.5));\", \"dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\", \"return clamp(dist,0.0,1.0);\", \"}\", \"float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\", \"float rings2 = float(rings);\", \"float step = PI*2.0 / float(ringsamples);\", \"float pw = cos(j*step)*i;\", \"float ph = sin(j*step)*i;\", \"float p = 1.0;\", \"if (pentagon) {\", \"p = penta(vec2(pw,ph));\", \"}\", \"col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\", \"return 1.0 * mix(1.0, i /rings2, bias) * p;\", \"}\", \"void main() {\", \"//scene depth calculation\", \"float depth = linearize(texture2D(tDepth,vUv.xy).x);\", \"// Blur depth?\", \"if (depthblur) {\", \"depth = linearize(bdepth(vUv.xy));\", \"}\", \"//focal plane calculation\", \"float fDepth = focalDepth;\", \"if (shaderFocus) {\", \"fDepth = linearize(texture2D(tDepth,focusCoords).x);\", \"}\", \"// dof blur factor calculation\", \"float blur = 0.0;\", \"if (manualdof) {\", \"float a = depth-fDepth; // Focal plane\", \"float b = (a-fdofstart)/fdofdist; // Far DoF\", \"float c = (-a-ndofstart)/ndofdist; // Near Dof\", \"blur = (a>0.0) ? b : c;\", \"} else {\", \"float f = focalLength; // focal length in mm\", \"float d = fDepth*1000.0; // focal plane in mm\", \"float o = depth*1000.0; // depth in mm\", \"float a = (o*f)/(o-f);\", \"float b = (d*f)/(d-f);\", \"float c = (d-f)/(d*fstop*CoC);\", \"blur = abs(a-b)*c;\", \"}\", \"blur = clamp(blur,0.0,1.0);\", \"// calculation of pattern for dithering\", \"vec2 noise = rand(vUv.xy)*dithering*blur;\", \"// getting blur x and y step factor\", \"float w = (1.0/textureWidth)*blur*maxblur+noise.x;\", \"float h = (1.0/textureHeight)*blur*maxblur+noise.y;\", \"// calculation of final color\", \"vec3 col = vec3(0.0);\", \"if(blur < 0.05) {\", \"//some optimization thingy\", \"col = texture2D(tColor, vUv.xy).rgb;\", \"} else {\", \"col = texture2D(tColor, vUv.xy).rgb;\", \"float s = 1.0;\", \"int ringsamples;\", \"for (int i = 1; i <= rings; i++) {\", \"/*unboxstart*/\", \"ringsamples = i * samples;\", \"for (int j = 0 ; j < maxringsamples ; j++) {\", \"if (j >= ringsamples) break;\", \"s += gather(float(i), float(j), ringsamples, col, w, h, blur);\", \"}\", \"/*unboxend*/\", \"}\", \"col /= s; //divide by sample count\", \"}\", \"if (showFocus) {\", \"col = debugFocus(col, blur, depth);\", \"}\", \"if (vignetting) {\", \"col *= vignette();\", \"}\", \"gl_FragColor.rgb = col;\", \"gl_FragColor.a = 1.0;\", \"} \"].join(\"\\n\")\n  };\n};","map":{"version":3,"sources":["E:/baking/hongpeibang/node_modules/three-js/addons/BokehShader2.js"],"names":["module","exports","THREE","BokehShader","uniforms","type","value","Vector2","vertexShader","join","fragmentShader"],"mappings":"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","sourcesContent":["module.exports = function( THREE ){\n\t/**\n\t * @author zz85 / https://github.com/zz85 | twitter.com/blurspline\n\t *\n\t * Depth-of-field shader with bokeh\n\t * ported from GLSL shader by Martins Upitis\n\t * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\n\t *\n\t * Requires #define RINGS and SAMPLES integers\n\t */\n\n\n\n\tTHREE.BokehShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"textureWidth\":  { type: \"f\", value: 1.0 },\n\t\t\t\"textureHeight\":  { type: \"f\", value: 1.0 },\n\n\t\t\t\"focalDepth\":   { type: \"f\", value: 1.0 },\n\t\t\t\"focalLength\":   { type: \"f\", value: 24.0 },\n\t\t\t\"fstop\": { type: \"f\", value: 0.9 },\n\n\t\t\t\"tColor\":   { type: \"t\", value: null },\n\t\t\t\"tDepth\":   { type: \"t\", value: null },\n\n\t\t\t\"maxblur\":  { type: \"f\", value: 1.0 },\n\n\t\t\t\"showFocus\":   { type: \"i\", value: 0 },\n\t\t\t\"manualdof\":   { type: \"i\", value: 0 },\n\t\t\t\"vignetting\":   { type: \"i\", value: 0 },\n\t\t\t\"depthblur\":   { type: \"i\", value: 0 },\n\n\t\t\t\"threshold\":  { type: \"f\", value: 0.5 },\n\t\t\t\"gain\":  { type: \"f\", value: 2.0 },\n\t\t\t\"bias\":  { type: \"f\", value: 0.5 },\n\t\t\t\"fringe\":  { type: \"f\", value: 0.7 },\n\n\t\t\t\"znear\":  { type: \"f\", value: 0.1 },\n\t\t\t\"zfar\":  { type: \"f\", value: 100 },\n\n\t\t\t\"noise\":  { type: \"i\", value: 1 },\n\t\t\t\"dithering\":  { type: \"f\", value: 0.0001 },\n\t\t\t\"pentagon\": { type: \"i\", value: 0 },\n\n\t\t\t\"shaderFocus\":  { type: \"i\", value: 1 },\n\t\t\t\"focusCoords\":  { type: \"v2\", value: new THREE.Vector2() },\n\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vUv = uv;\",\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"uniform sampler2D tColor;\",\n\t\t\t\"uniform sampler2D tDepth;\",\n\t\t\t\"uniform float textureWidth;\",\n\t\t\t\"uniform float textureHeight;\",\n\n\t\t\t\"const float PI = 3.14159265;\",\n\n\t\t\t\"uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\",\n\t\t\t\"uniform float focalLength; //focal length in mm\",\n\t\t\t\"uniform float fstop; //f-stop value\",\n\t\t\t\"uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\",\n\n\t\t\t\"/*\",\n\t\t\t\"make sure that these two values are the same for your camera, otherwise distances will be wrong.\",\n\t\t\t\"*/\",\n\n\t\t\t\"uniform float znear; // camera clipping start\",\n\t\t\t\"uniform float zfar; // camera clipping end\",\n\n\t\t\t\"//------------------------------------------\",\n\t\t\t\"//user variables\",\n\n\t\t\t\"const int samples = SAMPLES; //samples on the first ring\",\n\t\t\t\"const int rings = RINGS; //ring count\",\n\n\t\t\t\"const int maxringsamples = rings * samples;\",\n\n\t\t\t\"uniform bool manualdof; // manual dof calculation\",\n\t\t\t\"float ndofstart = 1.0; // near dof blur start\",\n\t\t\t\"float ndofdist = 2.0; // near dof blur falloff distance\",\n\t\t\t\"float fdofstart = 1.0; // far dof blur start\",\n\t\t\t\"float fdofdist = 3.0; // far dof blur falloff distance\",\n\n\t\t\t\"float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\",\n\n\t\t\t\"uniform bool vignetting; // use optical lens vignetting\",\n\n\t\t\t\"float vignout = 1.3; // vignetting outer border\",\n\t\t\t\"float vignin = 0.0; // vignetting inner border\",\n\t\t\t\"float vignfade = 22.0; // f-stops till vignete fades\",\n\n\t\t\t\"uniform bool shaderFocus;\",\n\t\t\t\"// disable if you use external focalDepth value\",\n\n\t\t\t\"uniform vec2 focusCoords;\",\n\t\t\t\"// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\",\n\t\t\t\"// if center of screen use vec2(0.5, 0.5);\",\n\n\t\t\t\"uniform float maxblur;\",\n\t\t\t\"//clamp value of max blur (0.0 = no blur, 1.0 default)\",\n\n\t\t\t\"uniform float threshold; // highlight threshold;\",\n\t\t\t\"uniform float gain; // highlight gain;\",\n\n\t\t\t\"uniform float bias; // bokeh edge bias\",\n\t\t\t\"uniform float fringe; // bokeh chromatic aberration / fringing\",\n\n\t\t\t\"uniform bool noise; //use noise instead of pattern for sample dithering\",\n\n\t\t\t\"uniform float dithering;\",\n\n\t\t\t\"uniform bool depthblur; // blur the depth buffer\",\n\t\t\t\"float dbsize = 1.25; // depth blur size\",\n\n\t\t\t\"/*\",\n\t\t\t\"next part is experimental\",\n\t\t\t\"not looking good with small sample and ring count\",\n\t\t\t\"looks okay starting from samples = 4, rings = 4\",\n\t\t\t\"*/\",\n\n\t\t\t\"uniform bool pentagon; //use pentagon as bokeh shape?\",\n\t\t\t\"float feather = 0.4; //pentagon shape feather\",\n\n\t\t\t\"//------------------------------------------\",\n\n\t\t\t\"float penta(vec2 coords) {\",\n\t\t\t\t\"//pentagonal shape\",\n\t\t\t\t\"float scale = float(rings) - 1.3;\",\n\t\t\t\t\"vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\",\n\t\t\t\t\"vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\",\n\t\t\t\t\"vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\",\n\t\t\t\t\"vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\",\n\t\t\t\t\"vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\",\n\t\t\t\t\"vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\",\n\n\t\t\t\t\"vec4  one = vec4( 1.0 );\",\n\n\t\t\t\t\"vec4 P = vec4((coords),vec2(scale, scale));\",\n\n\t\t\t\t\"vec4 dist = vec4(0.0);\",\n\t\t\t\t\"float inorout = -4.0;\",\n\n\t\t\t\t\"dist.x = dot( P, HS0 );\",\n\t\t\t\t\"dist.y = dot( P, HS1 );\",\n\t\t\t\t\"dist.z = dot( P, HS2 );\",\n\t\t\t\t\"dist.w = dot( P, HS3 );\",\n\n\t\t\t\t\"dist = smoothstep( -feather, feather, dist );\",\n\n\t\t\t\t\"inorout += dot( dist, one );\",\n\n\t\t\t\t\"dist.x = dot( P, HS4 );\",\n\t\t\t\t\"dist.y = HS5.w - abs( P.z );\",\n\n\t\t\t\t\"dist = smoothstep( -feather, feather, dist );\",\n\t\t\t\t\"inorout += dist.x;\",\n\n\t\t\t\t\"return clamp( inorout, 0.0, 1.0 );\",\n\t\t\t\"}\",\n\n\t\t\t\"float bdepth(vec2 coords) {\",\n\t\t\t\t\"// Depth buffer blur\",\n\t\t\t\t\"float d = 0.0;\",\n\t\t\t\t\"float kernel[9];\",\n\t\t\t\t\"vec2 offset[9];\",\n\n\t\t\t\t\"vec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;\",\n\n\t\t\t\t\"offset[0] = vec2(-wh.x,-wh.y);\",\n\t\t\t\t\"offset[1] = vec2( 0.0, -wh.y);\",\n\t\t\t\t\"offset[2] = vec2( wh.x -wh.y);\",\n\n\t\t\t\t\"offset[3] = vec2(-wh.x,  0.0);\",\n\t\t\t\t\"offset[4] = vec2( 0.0,   0.0);\",\n\t\t\t\t\"offset[5] = vec2( wh.x,  0.0);\",\n\n\t\t\t\t\"offset[6] = vec2(-wh.x, wh.y);\",\n\t\t\t\t\"offset[7] = vec2( 0.0,  wh.y);\",\n\t\t\t\t\"offset[8] = vec2( wh.x, wh.y);\",\n\n\t\t\t\t\"kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\",\n\t\t\t\t\"kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\",\n\t\t\t\t\"kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\",\n\n\n\t\t\t\t\"for( int i=0; i<9; i++ ) {\",\n\t\t\t\t\t\"float tmp = texture2D(tDepth, coords + offset[i]).r;\",\n\t\t\t\t\t\"d += tmp * kernel[i];\",\n\t\t\t\t\"}\",\n\n\t\t\t\t\"return d;\",\n\t\t\t\"}\",\n\n\n\t\t\t\"vec3 color(vec2 coords,float blur) {\",\n\t\t\t\t\"//processing the sample\",\n\n\t\t\t\t\"vec3 col = vec3(0.0);\",\n\t\t\t\t\"vec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);\",\n\n\t\t\t\t\"col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\",\n\t\t\t\t\"col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\",\n\t\t\t\t\"col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\",\n\n\t\t\t\t\"vec3 lumcoeff = vec3(0.299,0.587,0.114);\",\n\t\t\t\t\"float lum = dot(col.rgb, lumcoeff);\",\n\t\t\t\t\"float thresh = max((lum-threshold)*gain, 0.0);\",\n\t\t\t\t\"return col+mix(vec3(0.0),col,thresh*blur);\",\n\t\t\t\"}\",\n\n\t\t\t\"vec2 rand(vec2 coord) {\",\n\t\t\t\t\"// generating noise / pattern texture for dithering\",\n\n\t\t\t\t\"float noiseX = ((fract(1.0-coord.s*(textureWidth/2.0))*0.25)+(fract(coord.t*(textureHeight/2.0))*0.75))*2.0-1.0;\",\n\t\t\t\t\"float noiseY = ((fract(1.0-coord.s*(textureWidth/2.0))*0.75)+(fract(coord.t*(textureHeight/2.0))*0.25))*2.0-1.0;\",\n\n\t\t\t\t\"if (noise) {\",\n\t\t\t\t\t\"noiseX = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;\",\n\t\t\t\t\t\"noiseY = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;\",\n\t\t\t\t\"}\",\n\n\t\t\t\t\"return vec2(noiseX,noiseY);\",\n\t\t\t\"}\",\n\n\t\t\t\"vec3 debugFocus(vec3 col, float blur, float depth) {\",\n\t\t\t\t\"float edge = 0.002*depth; //distance based edge smoothing\",\n\t\t\t\t\"float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\",\n\t\t\t\t\"float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\",\n\n\t\t\t\t\"col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\",\n\t\t\t\t\"col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\",\n\n\t\t\t\t\"return col;\",\n\t\t\t\"}\",\n\n\t\t\t\"float linearize(float depth) {\",\n\t\t\t\t\"return -zfar * znear / (depth * (zfar - znear) - zfar);\",\n\t\t\t\"}\",\n\n\n\t\t\t\"float vignette() {\",\n\t\t\t\t\"float dist = distance(vUv.xy, vec2(0.5,0.5));\",\n\t\t\t\t\"dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\",\n\t\t\t\t\"return clamp(dist,0.0,1.0);\",\n\t\t\t\"}\",\n\n\t\t\t\"float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\",\n\t\t\t\t\"float rings2 = float(rings);\",\n\t\t\t\t\"float step = PI*2.0 / float(ringsamples);\",\n\t\t\t\t\"float pw = cos(j*step)*i;\",\n\t\t\t\t\"float ph = sin(j*step)*i;\",\n\t\t\t\t\"float p = 1.0;\",\n\t\t\t\t\"if (pentagon) {\",\n\t\t\t\t\t\"p = penta(vec2(pw,ph));\",\n\t\t\t\t\"}\",\n\t\t\t\t\"col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\",\n\t\t\t\t\"return 1.0 * mix(1.0, i /rings2, bias) * p;\",\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\t\t\t\t\"//scene depth calculation\",\n\n\t\t\t\t\"float depth = linearize(texture2D(tDepth,vUv.xy).x);\",\n\n\t\t\t\t\"// Blur depth?\",\n\t\t\t\t\"if (depthblur) {\",\n\t\t\t\t\t\"depth = linearize(bdepth(vUv.xy));\",\n\t\t\t\t\"}\",\n\n\t\t\t\t\"//focal plane calculation\",\n\n\t\t\t\t\"float fDepth = focalDepth;\",\n\n\t\t\t\t\"if (shaderFocus) {\",\n\n\t\t\t\t\t\"fDepth = linearize(texture2D(tDepth,focusCoords).x);\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"// dof blur factor calculation\",\n\n\t\t\t\t\"float blur = 0.0;\",\n\n\t\t\t\t\"if (manualdof) {\",\n\t\t\t\t\t\"float a = depth-fDepth; // Focal plane\",\n\t\t\t\t\t\"float b = (a-fdofstart)/fdofdist; // Far DoF\",\n\t\t\t\t\t\"float c = (-a-ndofstart)/ndofdist; // Near Dof\",\n\t\t\t\t\t\"blur = (a>0.0) ? b : c;\",\n\t\t\t\t\"} else {\",\n\t\t\t\t\t\"float f = focalLength; // focal length in mm\",\n\t\t\t\t\t\"float d = fDepth*1000.0; // focal plane in mm\",\n\t\t\t\t\t\"float o = depth*1000.0; // depth in mm\",\n\n\t\t\t\t\t\"float a = (o*f)/(o-f);\",\n\t\t\t\t\t\"float b = (d*f)/(d-f);\",\n\t\t\t\t\t\"float c = (d-f)/(d*fstop*CoC);\",\n\n\t\t\t\t\t\"blur = abs(a-b)*c;\",\n\t\t\t\t\"}\",\n\n\t\t\t\t\"blur = clamp(blur,0.0,1.0);\",\n\n\t\t\t\t\"// calculation of pattern for dithering\",\n\n\t\t\t\t\"vec2 noise = rand(vUv.xy)*dithering*blur;\",\n\n\t\t\t\t\"// getting blur x and y step factor\",\n\n\t\t\t\t\"float w = (1.0/textureWidth)*blur*maxblur+noise.x;\",\n\t\t\t\t\"float h = (1.0/textureHeight)*blur*maxblur+noise.y;\",\n\n\t\t\t\t\"// calculation of final color\",\n\n\t\t\t\t\"vec3 col = vec3(0.0);\",\n\n\t\t\t\t\"if(blur < 0.05) {\",\n\t\t\t\t\t\"//some optimization thingy\",\n\t\t\t\t\t\"col = texture2D(tColor, vUv.xy).rgb;\",\n\t\t\t\t\"} else {\",\n\t\t\t\t\t\"col = texture2D(tColor, vUv.xy).rgb;\",\n\t\t\t\t\t\"float s = 1.0;\",\n\t\t\t\t\t\"int ringsamples;\",\n\n\t\t\t\t\t\"for (int i = 1; i <= rings; i++) {\",\n\t\t\t\t\t\t\"/*unboxstart*/\",\n\t\t\t\t\t\t\"ringsamples = i * samples;\",\n\n\t\t\t\t\t\t\"for (int j = 0 ; j < maxringsamples ; j++) {\",\n\t\t\t\t\t\t\t\"if (j >= ringsamples) break;\",\n\t\t\t\t\t\t\t\"s += gather(float(i), float(j), ringsamples, col, w, h, blur);\",\n\t\t\t\t\t\t\"}\",\n\t\t\t\t\t\t\"/*unboxend*/\",\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"col /= s; //divide by sample count\",\n\t\t\t\t\"}\",\n\n\t\t\t\t\"if (showFocus) {\",\n\t\t\t\t\t\"col = debugFocus(col, blur, depth);\",\n\t\t\t\t\"}\",\n\n\t\t\t\t\"if (vignetting) {\",\n\t\t\t\t\t\"col *= vignette();\",\n\t\t\t\t\"}\",\n\n\t\t\t\t\"gl_FragColor.rgb = col;\",\n\t\t\t\t\"gl_FragColor.a = 1.0;\",\n\t\t\t\"} \"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\n}\n"]},"metadata":{},"sourceType":"script"}