{"ast":null,"code":"module.exports = function (THREE) {\n  /**\n   * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog\n   *\n   * Edge Detection Shader using Sobel filter\n   * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector\n   *\n   * aspect: vec2 of (1/width, 1/height)\n   */\n  THREE.EdgeShader2 = {\n    uniforms: {\n      \"tDiffuse\": {\n        type: \"t\",\n        value: null\n      },\n      \"aspect\": {\n        type: \"v2\",\n        value: new THREE.Vector2(512, 512)\n      }\n    },\n    vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"uniform vec2 aspect;\", \"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\", \"mat3 G[2];\", \"const mat3 g0 = mat3( 1.0, 2.0, 1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0 );\", \"const mat3 g1 = mat3( 1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0 );\", \"void main(void)\", \"{\", \"mat3 I;\", \"float cnv[2];\", \"vec3 sample;\", \"G[0] = g0;\", \"G[1] = g1;\",\n    /* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n    \"for (float i=0.0; i<3.0; i++)\", \"for (float j=0.0; j<3.0; j++) {\", \"sample = texture2D( tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\", \"I[int(i)][int(j)] = length(sample);\", \"}\",\n    /* calculate the convolution values for all the masks */\n    \"for (int i=0; i<2; i++) {\", \"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\", \"cnv[i] = dp3 * dp3; \", \"}\", \"gl_FragColor = vec4(0.5 * sqrt(cnv[0]*cnv[0]+cnv[1]*cnv[1]));\", \"} \"].join(\"\\n\")\n  };\n};","map":{"version":3,"sources":["E:/baking/hongpeibang/node_modules/three-js/addons/EdgeShader2.js"],"names":["module","exports","THREE","EdgeShader2","uniforms","type","value","Vector2","vertexShader","join","fragmentShader"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiB,UAAUC,KAAV,EAAiB;AACjC;;;;;;;;AASAA,EAAAA,KAAK,CAACC,WAAN,GAAoB;AAEnBC,IAAAA,QAAQ,EAAE;AAET,kBAAY;AAAEC,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAFH;AAGT,gBAAa;AAAED,QAAAA,IAAI,EAAE,IAAR;AAAcC,QAAAA,KAAK,EAAE,IAAIJ,KAAK,CAACK,OAAV,CAAmB,GAAnB,EAAwB,GAAxB;AAArB;AAHJ,KAFS;AAQnBC,IAAAA,YAAY,EAAE,CAEb,mBAFa,EAIb,eAJa,EAMZ,WANY,EAOZ,2EAPY,EASb,GATa,EAWZC,IAXY,CAWN,IAXM,CARK;AAqBnBC,IAAAA,cAAc,EAAE,CAEf,6BAFe,EAGf,mBAHe,EAIf,sBAJe,EAOf,oDAPe,EASf,YATe,EAWf,yEAXe,EAYf,yEAZe,EAef,iBAfe,EAgBf,GAhBe,EAiBd,SAjBc,EAkBd,eAlBc,EAmBd,cAnBc,EAqBd,YArBc,EAsBd,YAtBc;AAwBd;AACA,mCAzBc,EA0Bd,iCA1Bc,EA2Bb,sEA3Ba,EA4Bb,qCA5Ba,EA6Bd,GA7Bc;AA+Bd;AACA,+BAhCc,EAiCb,2EAjCa,EAkCb,sBAlCa,EAmCd,GAnCc,EAqCd,+DArCc,EAsCf,IAtCe,EAwCdD,IAxCc,CAwCR,IAxCQ;AArBG,GAApB;AAiEA,CA3ED","sourcesContent":["module.exports = function( THREE ){\n\t/**\n\t * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog\n\t *\n\t * Edge Detection Shader using Sobel filter\n\t * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector\n\t *\n\t * aspect: vec2 of (1/width, 1/height)\n\t */\n\n\tTHREE.EdgeShader2 = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\t\"aspect\":    { type: \"v2\", value: new THREE.Vector2( 512, 512 ) },\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vUv = uv;\",\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"uniform vec2 aspect;\",\n\n\n\t\t\t\"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\",\n\n\t\t\t\"mat3 G[2];\",\n\n\t\t\t\"const mat3 g0 = mat3( 1.0, 2.0, 1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0 );\",\n\t\t\t\"const mat3 g1 = mat3( 1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0 );\",\n\n\n\t\t\t\"void main(void)\",\n\t\t\t\"{\",\n\t\t\t\t\"mat3 I;\",\n\t\t\t\t\"float cnv[2];\",\n\t\t\t\t\"vec3 sample;\",\n\n\t\t\t\t\"G[0] = g0;\",\n\t\t\t\t\"G[1] = g1;\",\n\n\t\t\t\t/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n\t\t\t\t\"for (float i=0.0; i<3.0; i++)\",\n\t\t\t\t\"for (float j=0.0; j<3.0; j++) {\",\n\t\t\t\t\t\"sample = texture2D( tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\",\n\t\t\t\t\t\"I[int(i)][int(j)] = length(sample);\",\n\t\t\t\t\"}\",\n\n\t\t\t\t/* calculate the convolution values for all the masks */\n\t\t\t\t\"for (int i=0; i<2; i++) {\",\n\t\t\t\t\t\"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\",\n\t\t\t\t\t\"cnv[i] = dp3 * dp3; \",\n\t\t\t\t\"}\",\n\n\t\t\t\t\"gl_FragColor = vec4(0.5 * sqrt(cnv[0]*cnv[0]+cnv[1]*cnv[1]));\",\n\t\t\t\"} \",\n\n\t\t].join( \"\\n\" )\n\n\t};\n\n}\n"]},"metadata":{},"sourceType":"script"}