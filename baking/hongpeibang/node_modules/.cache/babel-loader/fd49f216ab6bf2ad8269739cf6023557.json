{"ast":null,"code":"module.exports = function (THREE) {\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   *\n   * Screen-space ambient occlusion shader\n   * - ported from\n   *   SSAO GLSL shader v1.2\n   *   assembled by Martins Upitis (martinsh) (http://devlog-martinsh.blogspot.com)\n   *   original technique is made by ArKano22 (http://www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)\n   * - modifications\n   * - modified to use RGBA packed depth texture (use clear color 1,1,1,1 for depth pass)\n   * - refactoring and optimizations\n   */\n  THREE.SSAOShader = {\n    uniforms: {\n      \"tDiffuse\": {\n        type: \"t\",\n        value: null\n      },\n      \"tDepth\": {\n        type: \"t\",\n        value: null\n      },\n      \"size\": {\n        type: \"v2\",\n        value: new THREE.Vector2(512, 512)\n      },\n      \"cameraNear\": {\n        type: \"f\",\n        value: 1\n      },\n      \"cameraFar\": {\n        type: \"f\",\n        value: 100\n      },\n      \"onlyAO\": {\n        type: \"i\",\n        value: 0\n      },\n      \"aoClamp\": {\n        type: \"f\",\n        value: 0.5\n      },\n      \"lumInfluence\": {\n        type: \"f\",\n        value: 0.5\n      }\n    },\n    vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform float cameraNear;\", \"uniform float cameraFar;\", \"uniform bool onlyAO;\", // use only ambient occlusion pass?\n    \"uniform vec2 size;\", // texture width, height\n    \"uniform float aoClamp;\", // depth clamp - reduces haloing at screen edges\n    \"uniform float lumInfluence;\", // how much luminance affects occlusion\n    \"uniform sampler2D tDiffuse;\", \"uniform sampler2D tDepth;\", \"varying vec2 vUv;\", // \"#define PI 3.14159265\",\n    \"#define DL 2.399963229728653\", // PI * ( 3.0 - sqrt( 5.0 ) )\n    \"#define EULER 2.718281828459045\", // user variables\n    \"const int samples = 8;\", // ao sample count\n    \"const float radius = 5.0;\", // ao radius\n    \"const bool useNoise = false;\", // use noise instead of pattern for sample dithering\n    \"const float noiseAmount = 0.0003;\", // dithering amount\n    \"const float diffArea = 0.4;\", // self-shadowing reduction\n    \"const float gDisplace = 0.4;\", // gauss bell center\n    // RGBA depth\n    \"float unpackDepth( const in vec4 rgba_depth ) {\", \"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\", \"float depth = dot( rgba_depth, bit_shift );\", \"return depth;\", \"}\", // generating noise / pattern texture for dithering\n    \"vec2 rand( const vec2 coord ) {\", \"vec2 noise;\", \"if ( useNoise ) {\", \"float nx = dot ( coord, vec2( 12.9898, 78.233 ) );\", \"float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );\", \"noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );\", \"} else {\", \"float ff = fract( 1.0 - coord.s * ( size.x / 2.0 ) );\", \"float gg = fract( coord.t * ( size.y / 2.0 ) );\", \"noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;\", \"}\", \"return ( noise * 2.0  - 1.0 ) * noiseAmount;\", \"}\", \"float readDepth( const in vec2 coord ) {\", \"float cameraFarPlusNear = cameraFar + cameraNear;\", \"float cameraFarMinusNear = cameraFar - cameraNear;\", \"float cameraCoef = 2.0 * cameraNear;\", // \"return ( 2.0 * cameraNear ) / ( cameraFar + cameraNear - unpackDepth( texture2D( tDepth, coord ) ) * ( cameraFar - cameraNear ) );\",\n    \"return cameraCoef / ( cameraFarPlusNear - unpackDepth( texture2D( tDepth, coord ) ) * cameraFarMinusNear );\", \"}\", \"float compareDepths( const in float depth1, const in float depth2, inout int far ) {\", \"float garea = 2.0;\", // gauss bell width\n    \"float diff = ( depth1 - depth2 ) * 100.0;\", // depth difference (0-100)\n    // reduce left bell width to avoid self-shadowing\n    \"if ( diff < gDisplace ) {\", \"garea = diffArea;\", \"} else {\", \"far = 1;\", \"}\", \"float dd = diff - gDisplace;\", \"float gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );\", \"return gauss;\", \"}\", \"float calcAO( float depth, float dw, float dh ) {\", \"float dd = radius - depth * radius;\", \"vec2 vv = vec2( dw, dh );\", \"vec2 coord1 = vUv + dd * vv;\", \"vec2 coord2 = vUv - dd * vv;\", \"float temp1 = 0.0;\", \"float temp2 = 0.0;\", \"int far = 0;\", \"temp1 = compareDepths( depth, readDepth( coord1 ), far );\", // DEPTH EXTRAPOLATION\n    \"if ( far > 0 ) {\", \"temp2 = compareDepths( readDepth( coord2 ), depth, far );\", \"temp1 += ( 1.0 - temp1 ) * temp2;\", \"}\", \"return temp1;\", \"}\", \"void main() {\", \"vec2 noise = rand( vUv );\", \"float depth = readDepth( vUv );\", \"float tt = clamp( depth, aoClamp, 1.0 );\", \"float w = ( 1.0 / size.x )  / tt + ( noise.x * ( 1.0 - noise.x ) );\", \"float h = ( 1.0 / size.y ) / tt + ( noise.y * ( 1.0 - noise.y ) );\", \"float ao = 0.0;\", \"float dz = 1.0 / float( samples );\", \"float z = 1.0 - dz / 2.0;\", \"float l = 0.0;\", \"for ( int i = 0; i <= samples; i ++ ) {\", \"float r = sqrt( 1.0 - z );\", \"float pw = cos( l ) * r;\", \"float ph = sin( l ) * r;\", \"ao += calcAO( depth, pw * w, ph * h );\", \"z = z - dz;\", \"l = l + DL;\", \"}\", \"ao /= float( samples );\", \"ao = 1.0 - ao;\", \"vec3 color = texture2D( tDiffuse, vUv ).rgb;\", \"vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );\", \"float lum = dot( color.rgb, lumcoeff );\", \"vec3 luminance = vec3( lum );\", \"vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\", // mix( color * ao, white, luminance )\n    \"if ( onlyAO ) {\", \"final = vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\", // ambient occlusion only\n    \"}\", \"gl_FragColor = vec4( final, 1.0 );\", \"}\"].join(\"\\n\")\n  };\n};","map":{"version":3,"sources":["E:/baking/hongpeibang/node_modules/three-js/addons/SSAOShader.js"],"names":["module","exports","THREE","SSAOShader","uniforms","type","value","Vector2","vertexShader","join","fragmentShader"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiB,UAAUC,KAAV,EAAiB;AACjC;;;;;;;;;;;;AAaAA,EAAAA,KAAK,CAACC,UAAN,GAAmB;AAElBC,IAAAA,QAAQ,EAAE;AAET,kBAAgB;AAAEC,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAFP;AAGT,gBAAgB;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAHP;AAIT,cAAgB;AAAED,QAAAA,IAAI,EAAE,IAAR;AAAcC,QAAAA,KAAK,EAAE,IAAIJ,KAAK,CAACK,OAAV,CAAmB,GAAnB,EAAwB,GAAxB;AAArB,OAJP;AAKT,oBAAgB;AAAEF,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OALP;AAMT,mBAAgB;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OANP;AAOT,gBAAgB;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAPP;AAQT,iBAAgB;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB,OARP;AAST,sBAAgB;AAAED,QAAAA,IAAI,EAAE,GAAR;AAAaC,QAAAA,KAAK,EAAE;AAApB;AATP,KAFQ;AAelBE,IAAAA,YAAY,EAAE,CAEb,mBAFa,EAIb,eAJa,EAMZ,WANY,EAQZ,2EARY,EAUb,GAVa,EAYZC,IAZY,CAYN,IAZM,CAfI;AA6BlBC,IAAAA,cAAc,EAAE,CAEf,2BAFe,EAGf,0BAHe,EAKf,sBALe,EAKc;AAE7B,wBAPe,EAOc;AAC7B,4BARe,EAQc;AAE7B,iCAVe,EAUiB;AAEhC,iCAZe,EAaf,2BAbe,EAef,mBAfe,EAiBf;AACA,kCAlBe,EAkBkB;AACjC,qCAnBe,EAqBf;AAEA,4BAvBe,EAuBe;AAC9B,+BAxBe,EAwBe;AAE9B,kCA1Be,EA0BsB;AACrC,uCA3Be,EA2BsB;AAErC,iCA7Be,EA6BkB;AACjC,kCA9Be,EA8BkB;AAGjC;AAEA,qDAnCe,EAqCd,4GArCc,EAsCd,6CAtCc,EAuCd,eAvCc,EAyCf,GAzCe,EA2Cf;AAEA,qCA7Ce,EA+Cd,aA/Cc,EAiDd,mBAjDc,EAmDb,oDAnDa,EAoDb,0DApDa,EAsDb,0EAtDa,EAwDd,UAxDc,EA0Db,uDA1Da,EA2Db,iDA3Da,EA6Db,oEA7Da,EA+Dd,GA/Dc,EAiEd,8CAjEc,EAmEf,GAnEe,EAqEf,0CArEe,EAuEd,mDAvEc,EAwEd,oDAxEc,EAyEd,sCAzEc,EA2Ed;AACA,iHA5Ec,EA+Ef,GA/Ee,EAiFf,sFAjFe,EAmFd,oBAnFc,EAmFgC;AAC9C,+CApFc,EAoFgC;AAE9C;AAEA,+BAxFc,EA0Fb,mBA1Fa,EA4Fd,UA5Fc,EA8Fb,UA9Fa,EAgGd,GAhGc,EAkGd,8BAlGc,EAmGd,iEAnGc,EAoGd,eApGc,EAsGf,GAtGe,EAwGf,mDAxGe,EA0Gd,qCA1Gc,EA2Gd,2BA3Gc,EA6Gd,8BA7Gc,EA8Gd,8BA9Gc,EAgHd,oBAhHc,EAiHd,oBAjHc,EAmHd,cAnHc,EAoHd,2DApHc,EAsHd;AAEA,sBAxHc,EA0Hb,2DA1Ha,EA2Hb,mCA3Ha,EA6Hd,GA7Hc,EA+Hd,eA/Hc,EAiIf,GAjIe,EAmIf,eAnIe,EAqId,2BArIc,EAsId,iCAtIc,EAwId,0CAxIc,EA0Id,qEA1Ic,EA2Id,oEA3Ic,EA6Id,iBA7Ic,EA+Id,oCA/Ic,EAgJd,2BAhJc,EAiJd,gBAjJc,EAmJd,yCAnJc,EAqJb,4BArJa,EAuJb,0BAvJa,EAwJb,0BAxJa,EAyJb,wCAzJa,EA0Jb,aA1Ja,EA2Jb,aA3Ja,EA6Jd,GA7Jc,EA+Jd,yBA/Jc,EAgKd,gBAhKc,EAkKd,8CAlKc,EAoKd,8CApKc,EAqKd,yCArKc,EAsKd,+BAtKc,EAwKd,wFAxKc,EAwK6E;AAE3F,qBA1Kc,EA4Kb,2EA5Ka,EA4KiE;AAE/E,OA9Kc,EAgLd,oCAhLc,EAkLf,GAlLe,EAoLdD,IApLc,CAoLR,IApLQ;AA7BE,GAAnB;AAqNA,CAnOD","sourcesContent":["module.exports = function( THREE ){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Screen-space ambient occlusion shader\n\t * - ported from\n\t *   SSAO GLSL shader v1.2\n\t *   assembled by Martins Upitis (martinsh) (http://devlog-martinsh.blogspot.com)\n\t *   original technique is made by ArKano22 (http://www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)\n\t * - modifications\n\t * - modified to use RGBA packed depth texture (use clear color 1,1,1,1 for depth pass)\n\t * - refactoring and optimizations\n\t */\n\n\tTHREE.SSAOShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\":     { type: \"t\", value: null },\n\t\t\t\"tDepth\":       { type: \"t\", value: null },\n\t\t\t\"size\":         { type: \"v2\", value: new THREE.Vector2( 512, 512 ) },\n\t\t\t\"cameraNear\":   { type: \"f\", value: 1 },\n\t\t\t\"cameraFar\":    { type: \"f\", value: 100 },\n\t\t\t\"onlyAO\":       { type: \"i\", value: 0 },\n\t\t\t\"aoClamp\":      { type: \"f\", value: 0.5 },\n\t\t\t\"lumInfluence\": { type: \"f\", value: 0.5 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vUv = uv;\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float cameraNear;\",\n\t\t\t\"uniform float cameraFar;\",\n\n\t\t\t\"uniform bool onlyAO;\",      // use only ambient occlusion pass?\n\n\t\t\t\"uniform vec2 size;\",        // texture width, height\n\t\t\t\"uniform float aoClamp;\",    // depth clamp - reduces haloing at screen edges\n\n\t\t\t\"uniform float lumInfluence;\",  // how much luminance affects occlusion\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t// \"#define PI 3.14159265\",\n\t\t\t\"#define DL 2.399963229728653\",  // PI * ( 3.0 - sqrt( 5.0 ) )\n\t\t\t\"#define EULER 2.718281828459045\",\n\n\t\t\t// user variables\n\n\t\t\t\"const int samples = 8;\",     // ao sample count\n\t\t\t\"const float radius = 5.0;\",  // ao radius\n\n\t\t\t\"const bool useNoise = false;\",      // use noise instead of pattern for sample dithering\n\t\t\t\"const float noiseAmount = 0.0003;\", // dithering amount\n\n\t\t\t\"const float diffArea = 0.4;\",   // self-shadowing reduction\n\t\t\t\"const float gDisplace = 0.4;\",  // gauss bell center\n\n\n\t\t\t// RGBA depth\n\n\t\t\t\"float unpackDepth( const in vec4 rgba_depth ) {\",\n\n\t\t\t\t\"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\",\n\t\t\t\t\"float depth = dot( rgba_depth, bit_shift );\",\n\t\t\t\t\"return depth;\",\n\n\t\t\t\"}\",\n\n\t\t\t// generating noise / pattern texture for dithering\n\n\t\t\t\"vec2 rand( const vec2 coord ) {\",\n\n\t\t\t\t\"vec2 noise;\",\n\n\t\t\t\t\"if ( useNoise ) {\",\n\n\t\t\t\t\t\"float nx = dot ( coord, vec2( 12.9898, 78.233 ) );\",\n\t\t\t\t\t\"float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );\",\n\n\t\t\t\t\t\"noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );\",\n\n\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\"float ff = fract( 1.0 - coord.s * ( size.x / 2.0 ) );\",\n\t\t\t\t\t\"float gg = fract( coord.t * ( size.y / 2.0 ) );\",\n\n\t\t\t\t\t\"noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"return ( noise * 2.0  - 1.0 ) * noiseAmount;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"float readDepth( const in vec2 coord ) {\",\n\n\t\t\t\t\"float cameraFarPlusNear = cameraFar + cameraNear;\",\n\t\t\t\t\"float cameraFarMinusNear = cameraFar - cameraNear;\",\n\t\t\t\t\"float cameraCoef = 2.0 * cameraNear;\",\n\n\t\t\t\t// \"return ( 2.0 * cameraNear ) / ( cameraFar + cameraNear - unpackDepth( texture2D( tDepth, coord ) ) * ( cameraFar - cameraNear ) );\",\n\t\t\t\t\"return cameraCoef / ( cameraFarPlusNear - unpackDepth( texture2D( tDepth, coord ) ) * cameraFarMinusNear );\",\n\n\n\t\t\t\"}\",\n\n\t\t\t\"float compareDepths( const in float depth1, const in float depth2, inout int far ) {\",\n\n\t\t\t\t\"float garea = 2.0;\",                         // gauss bell width\n\t\t\t\t\"float diff = ( depth1 - depth2 ) * 100.0;\",  // depth difference (0-100)\n\n\t\t\t\t// reduce left bell width to avoid self-shadowing\n\n\t\t\t\t\"if ( diff < gDisplace ) {\",\n\n\t\t\t\t\t\"garea = diffArea;\",\n\n\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\"far = 1;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"float dd = diff - gDisplace;\",\n\t\t\t\t\"float gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );\",\n\t\t\t\t\"return gauss;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"float calcAO( float depth, float dw, float dh ) {\",\n\n\t\t\t\t\"float dd = radius - depth * radius;\",\n\t\t\t\t\"vec2 vv = vec2( dw, dh );\",\n\n\t\t\t\t\"vec2 coord1 = vUv + dd * vv;\",\n\t\t\t\t\"vec2 coord2 = vUv - dd * vv;\",\n\n\t\t\t\t\"float temp1 = 0.0;\",\n\t\t\t\t\"float temp2 = 0.0;\",\n\n\t\t\t\t\"int far = 0;\",\n\t\t\t\t\"temp1 = compareDepths( depth, readDepth( coord1 ), far );\",\n\n\t\t\t\t// DEPTH EXTRAPOLATION\n\n\t\t\t\t\"if ( far > 0 ) {\",\n\n\t\t\t\t\t\"temp2 = compareDepths( readDepth( coord2 ), depth, far );\",\n\t\t\t\t\t\"temp1 += ( 1.0 - temp1 ) * temp2;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"return temp1;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vec2 noise = rand( vUv );\",\n\t\t\t\t\"float depth = readDepth( vUv );\",\n\n\t\t\t\t\"float tt = clamp( depth, aoClamp, 1.0 );\",\n\n\t\t\t\t\"float w = ( 1.0 / size.x )  / tt + ( noise.x * ( 1.0 - noise.x ) );\",\n\t\t\t\t\"float h = ( 1.0 / size.y ) / tt + ( noise.y * ( 1.0 - noise.y ) );\",\n\n\t\t\t\t\"float ao = 0.0;\",\n\n\t\t\t\t\"float dz = 1.0 / float( samples );\",\n\t\t\t\t\"float z = 1.0 - dz / 2.0;\",\n\t\t\t\t\"float l = 0.0;\",\n\n\t\t\t\t\"for ( int i = 0; i <= samples; i ++ ) {\",\n\n\t\t\t\t\t\"float r = sqrt( 1.0 - z );\",\n\n\t\t\t\t\t\"float pw = cos( l ) * r;\",\n\t\t\t\t\t\"float ph = sin( l ) * r;\",\n\t\t\t\t\t\"ao += calcAO( depth, pw * w, ph * h );\",\n\t\t\t\t\t\"z = z - dz;\",\n\t\t\t\t\t\"l = l + DL;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"ao /= float( samples );\",\n\t\t\t\t\"ao = 1.0 - ao;\",\n\n\t\t\t\t\"vec3 color = texture2D( tDiffuse, vUv ).rgb;\",\n\n\t\t\t\t\"vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );\",\n\t\t\t\t\"float lum = dot( color.rgb, lumcoeff );\",\n\t\t\t\t\"vec3 luminance = vec3( lum );\",\n\n\t\t\t\t\"vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\",  // mix( color * ao, white, luminance )\n\n\t\t\t\t\"if ( onlyAO ) {\",\n\n\t\t\t\t\t\"final = vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\",  // ambient occlusion only\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"gl_FragColor = vec4( final, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\n}\n"]},"metadata":{},"sourceType":"script"}